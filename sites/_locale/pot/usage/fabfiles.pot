# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Jeff Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-12-31 10:53+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/usage/fabfiles.rst:3
# dae1e788cc664ed5bca075f9916314bf
msgid "Fabfile construction and use"
msgstr ""

#: ../../docs/usage/fabfiles.rst:5
# 31394bd8986647f386c48f1d7c88e55d
msgid "This document contains miscellaneous sections about fabfiles, both how to best write them, and how to use them once written."
msgstr ""

#: ../../docs/usage/fabfiles.rst:11
# 1e54e479a39e4577a9595aa6106b893e
msgid "Fabfile discovery"
msgstr ""

#: ../../docs/usage/fabfiles.rst:13
# 5882add390354daebf402b3da36abe9d
msgid "Fabric is capable of loading Python modules (e.g. ``fabfile.py``) or packages (e.g. a ``fabfile/`` directory containing an ``__init__.py``). By default, it looks for something named (to Python's import machinery) ``fabfile`` - so either ``fabfile/`` or ``fabfile.py``."
msgstr ""

#: ../../docs/usage/fabfiles.rst:18
# 29e4d25964374574a8e2593f1df754e8
msgid "The fabfile discovery algorithm searches in the invoking user's current working directory or any parent directories. Thus, it is oriented around \"project\" use, where one keeps e.g. a ``fabfile.py`` at the root of a source code tree. Such a fabfile will then be discovered no matter where in the tree the user invokes ``fab``."
msgstr ""

#: ../../docs/usage/fabfiles.rst:24
# 8e3fc8fd31154186913e6e3c20b8eefe
msgid "The specific name to be searched for may be overridden on the command-line with the :option:`-f` option, or by adding a :ref:`fabricrc <fabricrc>` line which sets the value of ``fabfile``. For example, if you wanted to name your fabfile ``fab_tasks.py``, you could create such a file and then call ``fab -f fab_tasks.py <task name>``, or add ``fabfile = fab_tasks.py`` to ``~/.fabricrc``."
msgstr ""

#: ../../docs/usage/fabfiles.rst:31
# dada844c504a40bfb3097a19bcb9f41d
msgid "If the given fabfile name contains path elements other than a filename (e.g. ``../fabfile.py`` or ``/dir1/dir2/custom_fabfile``) it will be treated as a file path and directly checked for existence without any sort of searching. When in this mode, tilde-expansion will be applied, so one may refer to e.g. ``~/personal_fabfile.py``."
msgstr ""

#: ../../docs/usage/fabfiles.rst:39
# a32127a6dc5b47d2b9147e8bdd41107c
msgid "Fabric does a normal ``import`` (actually an ``__import__``) of your fabfile in order to access its contents -- it does not do any ``eval``-ing or similar. In order for this to work, Fabric temporarily adds the found fabfile's containing folder to the Python load path (and removes it immediately afterwards.)"
msgstr ""

#: ../../docs/usage/fabfiles.rst:45
# 15f78ed142ce400f9bdbbfd09f0998a7
msgid "The ability to load package fabfiles."
msgstr ""

#: ../../docs/usage/fabfiles.rst:52
# 5ab198237027468fbd412e14c4ea98b1
msgid "Importing Fabric"
msgstr ""

#: ../../docs/usage/fabfiles.rst:54
# 80052cb552754fb1aefa064d7b30c917
msgid "Because Fabric is just Python, you *can* import its components any way you want. However, for the purposes of encapsulation and convenience (and to make life easier for Fabric's packaging script) Fabric's public API is maintained in the ``fabric.api`` module."
msgstr ""

#: ../../docs/usage/fabfiles.rst:59
# 5be0d59cfbdb4e76a29733364c3ded43
msgid "All of Fabric's :doc:`../api/core/operations`, :doc:`../api/core/context_managers`, :doc:`../api/core/decorators` and :doc:`../api/core/utils` are included in this module as a single, flat namespace. This enables a very simple and consistent interface to Fabric within your fabfiles::"
msgstr ""

#: ../../docs/usage/fabfiles.rst:69
# 80e02eb8ff2a4036acc75fdeb7a67125
msgid "This is not technically best practices (for `a number of reasons`_) and if you're only using a couple of Fab API calls, it *is* probably a good idea to explicitly ``from fabric.api import env, run`` or similar. However, in most nontrivial fabfiles, you'll be using all or most of the API, and the star import::"
msgstr ""

#: ../../docs/usage/fabfiles.rst:77
# 175ab62ae6ff4079b9ea7128cc2d7dba
msgid "will be a lot easier to write and read than::"
msgstr ""

#: ../../docs/usage/fabfiles.rst:82
# f49d6928f7e048cc9c4b8c3b679fb08a
msgid "so in this case we feel pragmatism overrides best practices."
msgstr ""

#: ../../docs/usage/fabfiles.rst:88
# 2a864baeb23c4d11803d7e0e31b584f4
msgid "Defining tasks and importing callables"
msgstr ""

#: ../../docs/usage/fabfiles.rst:90
# dc180157c0594a19ae56d994e8f3c7a7
msgid "For important information on what exactly Fabric will consider as a task when it loads your fabfile, as well as notes on how best to import other code, please see :doc:`/usage/tasks` in the :doc:`execution` documentation."
msgstr ""

