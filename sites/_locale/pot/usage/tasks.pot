# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Jeff Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-12-31 10:53+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/usage/tasks.rst:3
# 6190b531f0c6400a97a18c9d99df80c1
msgid "Defining tasks"
msgstr ""

#: ../../docs/usage/tasks.rst:5
# 64355ef28164464fafbf1f315c575b2f
msgid "As of Fabric 1.1, there are two distinct methods you may use in order to define which objects in your fabfile show up as tasks:"
msgstr ""

#: ../../docs/usage/tasks.rst:8
# d1679af2e5314ef09b037137a27e3cba
msgid "The \"new\" method starting in 1.1 considers instances of `~fabric.tasks.Task` or its subclasses, and also descends into imported modules to allow building nested namespaces."
msgstr ""

#: ../../docs/usage/tasks.rst:11
# 9e4aafe353d1465eaf09d8c4cc71730c
msgid "The \"classic\" method from 1.0 and earlier considers all public callable objects (functions, classes etc) and only considers the objects in the fabfile itself with no recursing into imported module."
msgstr ""

#: ../../docs/usage/tasks.rst:16
# 5bf6a5a092204eb0b4f387edbf8dcb2f
msgid "These two methods are **mutually exclusive**: if Fabric finds *any* new-style task objects in your fabfile or in modules it imports, it will assume you've committed to this method of task declaration and won't consider any non-`~fabric.tasks.Task` callables. If *no* new-style tasks are found, it reverts to the classic behavior."
msgstr ""

#: ../../docs/usage/tasks.rst:22
# 392102feaeb74a99ae8867908b4abc0d
msgid "The rest of this document explores these two methods in detail."
msgstr ""

#: ../../docs/usage/tasks.rst:26
# d37d3a403f67424b937da66ab4664cf4
msgid "To see exactly what tasks in your fabfile may be executed via ``fab``, use :option:`fab --list <-l>`."
msgstr ""

#: ../../docs/usage/tasks.rst:32
# 661b483a82b74fc6a1bc6cd0f0ed6ce1
msgid "New-style tasks"
msgstr ""

#: ../../docs/usage/tasks.rst:34
# 54e84ae40cfa492a80885705711f19e7
msgid "Fabric 1.1 introduced the `~fabric.tasks.Task` class to facilitate new features and enable some programming best practices, specifically:"
msgstr ""

#: ../../docs/usage/tasks.rst:37
# f25a5b9d4c5f4f949065c4715209670b
msgid "**Object-oriented tasks**. Inheritance and all that comes with it can make for much more sensible code reuse than passing around simple function objects.  The classic style of task declaration didn't entirely rule this out, but it also didn't make it terribly easy."
msgstr ""

#: ../../docs/usage/tasks.rst:41
# 2d7a8330f433477096f57f60418a402d
msgid "**Namespaces**. Having an explicit method of declaring tasks makes it easier to set up recursive namespaces without e.g. polluting your task list with the contents of Python's ``os`` module (which would show up as valid \"tasks\" under the classic methodology.)"
msgstr ""

#: ../../docs/usage/tasks.rst:46
# df566c7c3f4243609d5d17309c1b24b2
msgid "With the introduction of `~fabric.tasks.Task`, there are two ways to set up new tasks:"
msgstr ""

#: ../../docs/usage/tasks.rst:49
# b5249c8650de497daf7fca7e8d73e9f4
msgid "Decorate a regular module level function with `@task <fabric.decorators.task>`, which transparently wraps the function in a `~fabric.tasks.Task` subclass.  The function name will be used as the task name when invoking."
msgstr ""

#: ../../docs/usage/tasks.rst:53
# 851630054a464cceac5807c1ca34b258
msgid "Subclass `~fabric.tasks.Task` (`~fabric.tasks.Task` itself is intended to be abstract), define a ``run`` method, and instantiate your subclass at module level. Instances' ``name`` attributes are used as the task name; if omitted the instance's variable name will be used instead."
msgstr ""

#: ../../docs/usage/tasks.rst:58
# afbdc28ba03449bcbf852cf9b57215d3
msgid "Use of new-style tasks also allows you to set up :ref:`namespaces <namespaces>`."
msgstr ""

#: ../../docs/usage/tasks.rst:65
# 10b20fa70b81400685275981139078a4
msgid "The ``@task`` decorator"
msgstr ""

#: ../../docs/usage/tasks.rst:67
# 001b7fe8f70b47568b3e719e07693ccd
msgid "The quickest way to make use of new-style task features is to wrap basic task functions with `@task <fabric.decorators.task>`::"
msgstr ""

#: ../../docs/usage/tasks.rst:76
# d67de0490896439fa345f81aa3a72c83
msgid "When this decorator is used, it signals to Fabric that *only* functions wrapped in the decorator are to be loaded up as valid tasks. (When not present, :ref:`classic-style task <classic-tasks>` behavior kicks in.)"
msgstr ""

#: ../../docs/usage/tasks.rst:81
# 42c0361f527d4a6580d487b0005ae5b3
msgid "Arguments"
msgstr ""

#: ../../docs/usage/tasks.rst:83
# 9a767785e7ca49cbaddf2e20dd7c26bf
msgid "`@task <fabric.decorators.task>` may also be called with arguments to customize its behavior. Any arguments not documented below are passed into the constructor of the ``task_class`` being used, with the function itself as the first argument (see :ref:`task-decorator-and-classes` for details.)"
msgstr ""

#: ../../docs/usage/tasks.rst:88
# f10c562ca8c74b548e4c8e9d7450a0a5
msgid "``task_class``: The `~fabric.tasks.Task` subclass used to wrap the decorated function. Defaults to `~fabric.tasks.WrappedCallableTask`."
msgstr ""

#: ../../docs/usage/tasks.rst:90
# 78caa2bdbfd74def9da4589612a7809b
msgid "``aliases``: An iterable of string names which will be used as aliases for the wrapped function. See :ref:`task-aliases` for details."
msgstr ""

#: ../../docs/usage/tasks.rst:92
# 21eef767fc7f47a99e2dbdec6c4aec62
msgid "``alias``: Like ``aliases`` but taking a single string argument instead of an iterable. If both ``alias`` and ``aliases`` are specified, ``aliases`` will take precedence."
msgstr ""

#: ../../docs/usage/tasks.rst:95
# 173aa625b54c47898d4fd342d28534b8
msgid "``default``: A boolean value determining whether the decorated task also stands in for its containing module as a task name. See :ref:`default-tasks`."
msgstr ""

#: ../../docs/usage/tasks.rst:97
# 77ffc98d8494433f8668d4f48ff1ef33
msgid "``name``: A string setting the name this task appears as to the command-line interface. Useful for task names that would otherwise shadow Python builtins (which is technically legal but frowned upon and bug-prone.)"
msgstr ""

#: ../../docs/usage/tasks.rst:104
# df3c08bb201e4bd59a6492e75e523e6d
msgid "Aliases"
msgstr ""

#: ../../docs/usage/tasks.rst:106
# 287ba0e34a174ace8317cd4eb9940ff5
msgid "Here's a quick example of using the ``alias`` keyword argument to facilitate use of both a longer human-readable task name, and a shorter name which is quicker to type::"
msgstr ""

#: ../../docs/usage/tasks.rst:116
# 79288e4d055e4d3f9c876e30c2860e63
msgid "Calling :option:`--list <-l>` on this fabfile would show both the original ``deploy_with_migrations`` and its alias ``dwm``::"
msgstr ""

#: ../../docs/usage/tasks.rst:125
# 2b3abb8ee5994c638c5450c38f7ac22f
msgid "When more than one alias for the same function is needed, simply swap in the ``aliases`` kwarg, which takes an iterable of strings instead of a single string."
msgstr ""

#: ../../docs/usage/tasks.rst:132
# 892e277261de4ef79143f17667c39529
msgid "Default tasks"
msgstr ""

#: ../../docs/usage/tasks.rst:134
# 26f55448b8c743118bffea52dd208828
msgid "In a similar manner to :ref:`aliases <task-aliases>`, it's sometimes useful to designate a given task within a module as the \"default\" task, which may be called by referencing *just* the module name. This can save typing and/or allow for neater organization when there's a single \"main\" task and a number of related tasks or subroutines."
msgstr ""

#: ../../docs/usage/tasks.rst:140
# ab1f9fd202ad453aa477a953606798b8
msgid "For example, a ``deploy`` submodule might contain tasks for provisioning new servers, pushing code, migrating databases, and so forth -- but it'd be very convenient to highlight a task as the default \"just deploy\" action. Such a ``deploy.py`` module might look like this::"
msgstr ""

#: ../../docs/usage/tasks.rst:166
# 0e24974c5d434afb96de744ab5d66333
msgid "With the following task list (assuming a simple top level ``fabfile.py`` that just imports ``deploy``)::"
msgstr ""

#: ../../docs/usage/tasks.rst:176
# 64a394ade4fa4812817b131317af1322
msgid "Calling ``deploy.full_deploy`` on every deploy could get kind of old, or somebody new to the team might not be sure if that's really the right task to run."
msgstr ""

#: ../../docs/usage/tasks.rst:178
# fe9bc876df0844478a313c9fa5e5eb17
msgid "Using the ``default`` kwarg to `@task <fabric.decorators.task>`, we can tag e.g. ``full_deploy`` as the default task::"
msgstr ""

#: ../../docs/usage/tasks.rst:185
# da11cbe994534a52868edfab8d97c919
msgid "Doing so updates the task list like so::"
msgstr ""

#: ../../docs/usage/tasks.rst:196
# 185cb9a71ab54053bb91c6f37b3402f9
msgid "Note that ``full_deploy`` still exists as its own explicit task -- but now ``deploy`` shows up as a sort of top level alias for ``full_deploy``."
msgstr ""

#: ../../docs/usage/tasks.rst:199
# 9208997c759d417b8062edc3486d1214
msgid "If multiple tasks within a module have ``default=True`` set, the last one to be loaded (typically the one lowest down in the file) will take precedence."
msgstr ""

#: ../../docs/usage/tasks.rst:203
# 5e2c62b3700b4f9dba6a47c81072898b
msgid "Top-level default tasks"
msgstr ""

#: ../../docs/usage/tasks.rst:205
# 67702ccc97974c89880718767a1cc1e2
msgid "Using ``@task(default=True)`` in the top level fabfile will cause the denoted task to execute when a user invokes ``fab`` without any task names (similar to e.g. ``make``.) When using this shortcut, it is not possible to specify arguments to the task itself -- use a regular invocation of the task if this is necessary."
msgstr ""

#: ../../docs/usage/tasks.rst:214
# 1347ba425dda4e13a16b384315978439
msgid "``Task`` subclasses"
msgstr ""

#: ../../docs/usage/tasks.rst:216
# 00031325eab748aab31838b65c1bf23c
msgid "If you're used to :ref:`classic-style tasks <classic-tasks>`, an easy way to think about `~fabric.tasks.Task` subclasses is that their ``run`` method is directly equivalent to a classic task; its arguments are the task arguments (other than ``self``) and its body is what gets executed."
msgstr ""

#: ../../docs/usage/tasks.rst:221
# 4bc11f7aee624ba99df21dec9de4b00e
msgid "For example, this new-style task::"
msgstr ""

#: ../../docs/usage/tasks.rst:231
# 7b0dd5dbfc424627b5d5cd005378c927
msgid "is exactly equivalent to this function-based task::"
msgstr ""

#: ../../docs/usage/tasks.rst:238
# cc7c1f0a848540bab448f9ad71360065
msgid "Note how we had to instantiate an instance of our class; that's simply normal Python object-oriented programming at work. While it's a small bit of boilerplate right now -- for example, Fabric doesn't care about the name you give the instantiation, only the instance's ``name`` attribute -- it's well worth the benefit of having the power of classes available."
msgstr ""

#: ../../docs/usage/tasks.rst:244
# c07e11c83cba49b399cb53d41b691d6c
msgid "We plan to extend the API in the future to make this experience a bit smoother."
msgstr ""

#: ../../docs/usage/tasks.rst:249
# 78f1cadef4e84d80a40eff13ec9742f4
msgid "Using custom subclasses with ``@task``"
msgstr ""

#: ../../docs/usage/tasks.rst:251
# fb2570f4c1db47b8b04cdd3b65bcbfa0
msgid "It's possible to marry custom `~fabric.tasks.Task` subclasses with `@task <fabric.decorators.task>`. This may be useful in cases where your core execution logic doesn't do anything class/object-specific, but you want to take advantage of class metaprogramming or similar techniques."
msgstr ""

#: ../../docs/usage/tasks.rst:256
# 0994c3ffa70f4a78a83ed2ca9853fb20
msgid "Specifically, any `~fabric.tasks.Task` subclass which is designed to take in a callable as its first constructor argument (as the built-in `~fabric.tasks.WrappedCallableTask` does) may be specified as the ``task_class`` argument to `@task <fabric.decorators.task>`."
msgstr ""

#: ../../docs/usage/tasks.rst:261
# 506c9a0bb36b48b7834ead511f28833d
msgid "Fabric will automatically instantiate a copy of the given class, passing in the wrapped function as the first argument. All other args/kwargs given to the decorator (besides the \"special\" arguments documented in :ref:`task-decorator-arguments`) are added afterwards."
msgstr ""

#: ../../docs/usage/tasks.rst:266
# 2c7d2659390a408591320b40fa77f5ad
msgid "Here's a brief and somewhat contrived example to make this obvious::"
msgstr ""

#: ../../docs/usage/tasks.rst:284
# 48096c48873d475e908f8388352df37d
msgid "When this fabfile is loaded, a copy of ``CustomTask`` is instantiated, effectively calling::"
msgstr ""

#: ../../docs/usage/tasks.rst:288
# f65bed3dac334fb9977368a84f4f7411
msgid "Note how the ``alias`` kwarg is stripped out by the decorator itself and never reaches the class instantiation; this is identical in function to how :ref:`command-line task arguments <task-arguments>` work."
msgstr ""

#: ../../docs/usage/tasks.rst:295
# 7af567dbaab3443391a9cf7643bebb3c
msgid "Namespaces"
msgstr ""

#: ../../docs/usage/tasks.rst:297
# 8cf3e3a8a9ab4533a3d9bc21cecacc0e
msgid "With :ref:`classic tasks <classic-tasks>`, fabfiles were limited to a single, flat set of task names with no real way to organize them.  In Fabric 1.1 and newer, if you declare tasks the new way (via `@task <fabric.decorators.task>` or your own `~fabric.tasks.Task` subclass instances) you may take advantage of **namespacing**:"
msgstr ""

#: ../../docs/usage/tasks.rst:303
# c9ed0d3aa1ae48bc9c2e0b8f9f018938
msgid "Any module objects imported into your fabfile will be recursed into, looking for additional task objects."
msgstr ""

#: ../../docs/usage/tasks.rst:305
# 505c94aa09754e19aee6f94490c8e676
msgid "Within submodules, you may control which objects are \"exported\" by using the standard Python ``__all__`` module-level variable name (thought they should still be valid new-style task objects.)"
msgstr ""

#: ../../docs/usage/tasks.rst:308
# 2343fe6216f54c20af58a82de3f467a9
msgid "These tasks will be given new dotted-notation names based on the modules they came from, similar to Python's own import syntax."
msgstr ""

#: ../../docs/usage/tasks.rst:311
# 12f9b87e9eda430ba3539109ae305d38
msgid "Let's build up a fabfile package from simple to complex and see how this works."
msgstr ""

#: ../../docs/usage/tasks.rst:314
# d0079490918a493b9e6bcfd5b2e47cf9
msgid "Basic"
msgstr ""

#: ../../docs/usage/tasks.rst:316
# 82ee77fd8db842fea60fababa4d1efb7
msgid "We start with a single `__init__.py` containing a few tasks (the Fabric API import omitted for brevity)::"
msgstr ""

#: ../../docs/usage/tasks.rst:327
# eb0dbcb34b244f8cb1f2569389a7e2f7
msgid "The output of ``fab --list`` would look something like this::"
msgstr ""

#: ../../docs/usage/tasks.rst:332
# 09ad6fdfcb884ebd9d8b38dbf0cc36e0
msgid "There's just one namespace here: the \"root\" or global namespace. Looks simple now, but in a real-world fabfile with dozens of tasks, it can get difficult to manage."
msgstr ""

#: ../../docs/usage/tasks.rst:337
# 9b3cd13ed7c34d8fb7af4b1491a1bb06
msgid "Importing a submodule"
msgstr ""

#: ../../docs/usage/tasks.rst:339
# 731eb9c99dec45f4a3942c2188043fa5
msgid "As mentioned above, Fabric will examine any imported module objects for tasks, regardless of where that module exists on your Python import path.  For now we just want to include our own, \"nearby\" tasks, so we'll make a new submodule in our package for dealing with, say, load balancers -- ``lb.py``::"
msgstr ""

#: ../../docs/usage/tasks.rst:348
# 816c2a325f184af3b0afe079e4027633
msgid "And we'll add this to the top of ``__init__.py``::"
msgstr ""

#: ../../docs/usage/tasks.rst:352
# 7d02cf2ab53942af86f6d4a916b14360
msgid "Now ``fab --list`` shows us::"
msgstr ""

#: ../../docs/usage/tasks.rst:358
# 8c6faa3b475b48869eb39d2585088127
msgid "Again, with only one task in its own submodule, it looks kind of silly, but the benefits should be pretty obvious."
msgstr ""

#: ../../docs/usage/tasks.rst:362
# 0f4f2a9b4b0d4db0a47481e0ccbeff89
msgid "Going deeper"
msgstr ""

#: ../../docs/usage/tasks.rst:364
# c56b3c5cf7c14c39be70e6377527c178
msgid "Namespacing isn't limited to just one level. Let's say we had a larger setup and wanted a namespace for database related tasks, with additional differentiation inside that. We make a sub-package named ``db/`` and inside it, a ``migrations.py`` module::"
msgstr ""

#: ../../docs/usage/tasks.rst:377
# 60b4b6fa386b4292bde3a7ffd7450a6a
msgid "We need to make sure that this module is visible to anybody importing ``db``, so we add it to the sub-package's ``__init__.py``::"
msgstr ""

#: ../../docs/usage/tasks.rst:382
# d3fa98e8f85c42a4b48c37bea7ebdd64
msgid "As a final step, we import the sub-package into our root-level ``__init__.py``, so now its first few lines look like this::"
msgstr ""

#: ../../docs/usage/tasks.rst:388
# ef9537b17d7145a0a78b604bfd757bb9
msgid "After all that, our file tree looks like this::"
msgstr ""

#: ../../docs/usage/tasks.rst:397
# 0831c2519c55411d9c7db01913caecf2
msgid "and ``fab --list`` shows::"
msgstr ""

#: ../../docs/usage/tasks.rst:405
# 991ad97bc7a14a64896286df422c54da
msgid "We could also have specified (or imported) tasks directly into ``db/__init__.py``, and they would show up as ``db.<whatever>`` as you might expect."
msgstr ""

#: ../../docs/usage/tasks.rst:410
# d7fd4a46f7fb478ca2cec7177dff05eb
msgid "Limiting with ``__all__``"
msgstr ""

#: ../../docs/usage/tasks.rst:412
# fc819ab51bef4bf490367e6323b16f00
msgid "You may limit what Fabric \"sees\" when it examines imported modules, by using the Python convention of a module level ``__all__`` variable (a list of variable names.) If we didn't want the ``db.migrations.run`` task to show up by default for some reason, we could add this to the top of ``db/migrations.py``::"
msgstr ""

#: ../../docs/usage/tasks.rst:419
# de5cb3c5b2054f4ca6bd5ddc1adc9b52
msgid "Note the lack of ``'run'`` there. You could, if needed, import ``run`` directly into some other part of the hierarchy, but otherwise it'll remain hidden."
msgstr ""

#: ../../docs/usage/tasks.rst:423
# b9b6dc68306d4f0997212e753284a555
msgid "Switching it up"
msgstr ""

#: ../../docs/usage/tasks.rst:425
# bf81a1212a914a0e84484468c5fac254
msgid "We've been keeping our fabfile package neatly organized and importing it in a straightforward manner, but the filesystem layout doesn't actually matter here. All Fabric's loader cares about is the names the modules are given when they're imported."
msgstr ""

#: ../../docs/usage/tasks.rst:430
# 27a437c6dc66404ba1cad0030cc44b87
msgid "For example, if we changed the top of our root ``__init__.py`` to look like this::"
msgstr ""

#: ../../docs/usage/tasks.rst:435
# 94384656d0904843a8c18289f88f3c58
msgid "Our task list would change thusly::"
msgstr ""

#: ../../docs/usage/tasks.rst:443
# 103d644c8f49464ba3ad8113788ac4bd
msgid "This applies to any other import -- you could import third party modules into your own task hierarchy, or grab a deeply nested module and make it appear near the top level."
msgstr ""

#: ../../docs/usage/tasks.rst:448
# 3cbcf6a6a3414afdb63404c1d2463bda
msgid "Nested list output"
msgstr ""

#: ../../docs/usage/tasks.rst:450
# 49ecb77d42564aad915e3303d50fda16
msgid "As a final note, we've been using the default Fabric :option:`--list <-l>` output during this section -- it makes it more obvious what the actual task names are. However, you can get a more nested or tree-like view by passing ``nested`` to the :option:`--list-format <-F>` option::"
msgstr ""

#: ../../docs/usage/tasks.rst:467
# 9de683b9b63848a2b2f1e888b0fa83e3
msgid "While it slightly obfuscates the \"real\" task names, this view provides a handy way of noting the organization of tasks in large namespaces."
msgstr ""

#: ../../docs/usage/tasks.rst:474
# d060b58dfc344561a39e76c95ae1c8f9
msgid "Classic tasks"
msgstr ""

#: ../../docs/usage/tasks.rst:476
# 4098079070ff441a999eb675cab9cf8f
msgid "When no new-style `~fabric.tasks.Task`-based tasks are found, Fabric will consider any callable object found in your fabfile, **except** the following:"
msgstr ""

#: ../../docs/usage/tasks.rst:479
# 5e61ff00acd54ee2840cec128b5e9c76
msgid "Callables whose name starts with an underscore (``_``). In other words, Python's usual \"private\" convention holds true here."
msgstr ""

#: ../../docs/usage/tasks.rst:481
# f930828c4d5b41ca9d0349122accd04f
msgid "Callables defined within Fabric itself. Fabric's own functions such as `~fabric.operations.run` and `~fabric.operations.sudo`  will not show up in your task list."
msgstr ""

#: ../../docs/usage/tasks.rst:487
# feb3ee798f454965a5f36a730ff27ccc
msgid "Imports"
msgstr ""

#: ../../docs/usage/tasks.rst:489
# beefad32988f4f21949922a4ba4586e6
msgid "Python's ``import`` statement effectively includes the imported objects in your module's namespace. Since Fabric's fabfiles are just Python modules, this means that imports are also considered as possible classic-style tasks, alongside anything defined in the fabfile itself."
msgstr ""

#: ../../docs/usage/tasks.rst:495
# fd5aeef4b98544ce8e8b617638a20974
msgid "This only applies to imported *callable objects* -- not modules. Imported modules only come into play if they contain :ref:`new-style tasks <new-style-tasks>`, at which point this section no longer applies."
msgstr ""

#: ../../docs/usage/tasks.rst:500
# fab2891c9da548fdafc3c5d956d73818
msgid "Because of this, we strongly recommend that you use the ``import module`` form of importing, followed by ``module.callable()``, which will result in a cleaner fabfile API than doing ``from module import callable``."
msgstr ""

#: ../../docs/usage/tasks.rst:504
# 689c950897a248ea8668c7a92e5c9e57
msgid "For example, here's a sample fabfile which uses ``urllib.urlopen`` to get some data out of a webservice::"
msgstr ""

#: ../../docs/usage/tasks.rst:515
# e4625fca8a6f45659702e0de7cedbcf4
msgid "This looks simple enough, and will run without error. However, look what happens if we run :option:`fab --list <-l>` on this fabfile::"
msgstr ""

#: ../../docs/usage/tasks.rst:524
# d553d05715a64c22a5ad9dd891d09063
msgid "Our fabfile of only one task is showing two \"tasks\", which is bad enough, and an unsuspecting user might accidentally try to call ``fab urlopen``, which probably won't work very well. Imagine any real-world fabfile, which is likely to be much more complex, and hopefully you can see how this could get messy fast."
msgstr ""

#: ../../docs/usage/tasks.rst:530
# 9276576565a949fbab9841d4013a30a2
msgid "For reference, here's the recommended way to do it::"
msgstr ""

#: ../../docs/usage/tasks.rst:540
# e33f5b5080834872b7d6ec9e3332cb2e
msgid "It's a simple change, but it'll make anyone using your fabfile a bit happier."
msgstr ""

