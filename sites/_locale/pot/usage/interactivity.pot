# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Jeff Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-12-31 10:53+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../docs/usage/interactivity.rst:3
# 60b9734438bb4c31b394ecd99a8a9450
msgid "Interaction with remote programs"
msgstr ""

#: ../../docs/usage/interactivity.rst:5
# dc37f26f98064474b81f2c917dbdad7e
msgid "Fabric's primary operations, `~fabric.operations.run` and `~fabric.operations.sudo`, are capable of sending local input to the remote end, in a manner nearly identical to the ``ssh`` program. For example, programs which display password prompts (e.g. a database dump utility, or changing a user's password) will behave just as if you were interacting with them directly."
msgstr ""

#: ../../docs/usage/interactivity.rst:12
# 0daf2e08577444efa58275350fbaac6a
msgid "However, as with ``ssh`` itself, Fabric's implementation of this feature is subject to a handful of limitations which are not always intuitive. This document discusses such issues in detail."
msgstr ""

#: ../../docs/usage/interactivity.rst:17
# a742b64b36cf4b1c94c5f2d3f1c6668e
msgid "Readers unfamiliar with the basics of Unix stdout and stderr pipes, and/or terminal devices, may wish to visit the Wikipedia pages for `Unix pipelines <http://en.wikipedia.org/wiki/Pipe_(Unix)>`_ and `Pseudo terminals <http://en.wikipedia.org/wiki/Pseudo_terminal>`_ respectively."
msgstr ""

#: ../../docs/usage/interactivity.rst:26
# 70aa2276b2854d448d93a19e4acf8a95
msgid "Combining stdout and stderr"
msgstr ""

#: ../../docs/usage/interactivity.rst:28
# 20164b8bfb3d4e5c81b0e04e90167f29
msgid "The first issue to be aware of is that of the stdout and stderr streams, and why they are separated or combined as needed."
msgstr ""

#: ../../docs/usage/interactivity.rst:32
# 6be7d2317a65420c8e3729d1af903d51
msgid "Buffering"
msgstr ""

#: ../../docs/usage/interactivity.rst:34
# 4ab501e793624740afe07edc770964ff
msgid "Fabric 0.9.x and earlier, and Python itself, buffer output on a line-by-line basis: text is not printed to the user until a newline character is found. This works fine in most situations but becomes problematic when one needs to deal with partial-line output such as prompts."
msgstr ""

#: ../../docs/usage/interactivity.rst:40
# 0ecf1d20d1c149c296e659c919160730
msgid "Line-buffered output can make programs appear to halt or freeze for no reason, as prompts print out text without a newline, waiting for the user to enter their input and press Return."
msgstr ""

#: ../../docs/usage/interactivity.rst:44
# 0da59b59d9384bb083d20091f452bcaa
msgid "Newer Fabric versions buffer both input and output on a character-by-character basis in order to make interaction with prompts possible. This has the convenient side effect of enabling interaction with complex programs utilizing the \"curses\" libraries or which otherwise redraw the screen (think ``top``)."
msgstr ""

#: ../../docs/usage/interactivity.rst:50
# cb69691946b04008883ded822e7843cf
msgid "Crossing the streams"
msgstr ""

#: ../../docs/usage/interactivity.rst:52
# 97f158affe2b4d17b5211ece64b66528
msgid "Unfortunately, printing to stderr and stdout simultaneously (as many programs do) means that when the two streams are printed independently one byte at a time, they can become garbled or meshed together. While this can sometimes be mitigated by line-buffering one of the streams and not the other, it's still a serious issue."
msgstr ""

#: ../../docs/usage/interactivity.rst:58
# 1d0c65a4a85649aba92d1a5705abde77
msgid "To solve this problem, Fabric uses a setting in our SSH layer which merges the two streams at a low level and causes output to appear more naturally. This setting is represented in Fabric as the :ref:`combine-stderr` env var and keyword argument, and is ``True`` by default."
msgstr ""

#: ../../docs/usage/interactivity.rst:63
# ee3864dcd86540f6af141bff7431d5ac
msgid "Due to this default setting, output will appear correctly, but at the cost of an empty ``.stderr`` attribute on the return values of `~fabric.operations.run`/`~fabric.operations.sudo`, as all output will appear to be stdout."
msgstr ""

#: ../../docs/usage/interactivity.rst:68
# 1dac2df8db3545f085aa5bcd9ca39c41
msgid "Conversely, users requiring a distinct stderr stream at the Python level and who aren't bothered by garbled user-facing output (or who are hiding stdout and stderr from the command in question) may opt to set this to ``False`` as needed."
msgstr ""

#: ../../docs/usage/interactivity.rst:77
# 811bc1782f8b46c0a7a3ae746e656a36
msgid "Pseudo-terminals"
msgstr ""

#: ../../docs/usage/interactivity.rst:79
# e04a98f20f03407a8bd27a06e068553c
msgid "The other main issue to consider when presenting interactive prompts to users is that of echoing the user's own input."
msgstr ""

#: ../../docs/usage/interactivity.rst:83
# 8404f228e470403abff68a11f1a018c7
msgid "Echoes"
msgstr ""

#: ../../docs/usage/interactivity.rst:85
# ea43a2c70db64b178be97ab85e1fc284
msgid "Typical terminal applications or bona fide text terminals (e.g. when using a Unix system without a running GUI) present programs with a terminal device called a tty or pty (for pseudo-terminal). These automatically echo all text typed into them back out to the user (via stdout), as interaction without seeing what you had just typed would be difficult. Terminal devices are also able to conditionally turn off echoing, allowing secure password prompts."
msgstr ""

#: ../../docs/usage/interactivity.rst:92
# dc154f433f824922b8f642b2ca42a9e5
msgid "However, it's possible for programs to be run without a tty or pty present at all (consider cron jobs, for example) and in this situation, any stdin data being fed to the program won't be echoed. This is desirable for programs being run without any humans around, and it's also Fabric's old default mode of operation."
msgstr ""

#: ../../docs/usage/interactivity.rst:99
# df1d1239dfa94c61bc33f0000bf43d24
msgid "Fabric's approach"
msgstr ""

#: ../../docs/usage/interactivity.rst:101
# d3127ada3dcf420987f286e45ba76365
msgid "Unfortunately, in the context of executing commands via Fabric, when no pty is present to echo a user's stdin, Fabric must echo it for them. This is sufficient for many applications, but it presents problems for password prompts, which become insecure."
msgstr ""

#: ../../docs/usage/interactivity.rst:106
# c33bf3cbb7eb45a6a82cb742a812d9fc
msgid "In the interests of security and meeting the principle of least surprise (insofar as users are typically expecting things to behave as they would when run in a terminal emulator), Fabric 1.0 and greater force a pty by default. With a pty enabled, Fabric simply allows the remote end to handle echoing or hiding of stdin and does not echo anything itself."
msgstr ""

#: ../../docs/usage/interactivity.rst:113
# 585c2316280345c5b248867d96605283
msgid "In addition to allowing normal echo behavior, a pty also means programs that behave differently when attached to a terminal device will then do so. For example, programs that colorize output on terminals but not when run in the background will print colored output. Be wary of this if you inspect the return value of `~fabric.operations.run` or `~fabric.operations.sudo`!"
msgstr ""

#: ../../docs/usage/interactivity.rst:119
# 2656575500b14e938ae6cefed6016839
msgid "For situations requiring the pty behavior turned off, the :option:`--no-pty` command-line argument and :ref:`always-use-pty` env var may be used."
msgstr ""

#: ../../docs/usage/interactivity.rst:124
# c09fb8f7490f44379e6b5d6138afd248
msgid "Combining the two"
msgstr ""

#: ../../docs/usage/interactivity.rst:126
# b43df4552b8545a2854e029b2800deb9
msgid "As a final note, keep in mind that use of pseudo-terminals effectively implies combining stdout and stderr -- in much the same way as the :ref:`combine_stderr <combine_streams>` setting does. This is because a terminal device naturally sends both stdout and stderr to the same place -- the user's display -- thus making it impossible to differentiate between them."
msgstr ""

#: ../../docs/usage/interactivity.rst:132
# 4bbe010836d845df8c71c55ec64950ea
msgid "However, at the Fabric level, the two groups of settings are distinct from one another and may be combined in various ways. The default is for both to be set to ``True``; the other combinations are as follows:"
msgstr ""

#: ../../docs/usage/interactivity.rst:136
# 3606ef3f5ef34e02b09e51f12aed376b
msgid "``run(\"cmd\", pty=False, combine_stderr=True)``: will cause Fabric to echo all stdin itself, including passwords, as well as potentially altering ``cmd``'s behavior. Useful if ``cmd`` behaves undesirably when run under a pty and you're not concerned about password prompts."
msgstr ""

#: ../../docs/usage/interactivity.rst:140
# 950d253321014ae0aeabe8a5ebc6eb03
msgid "``run(\"cmd\", pty=False, combine_stderr=False)``: with both settings ``False``, Fabric will echo stdin and won't issue a pty -- and this is highly likely to result in undesired behavior for all but the simplest commands. However, it is also the only way to access a distinct stderr stream, which is occasionally useful."
msgstr ""

#: ../../docs/usage/interactivity.rst:145
# 0a9d3d196bb7424eb9f2bc5c9560c9e2
msgid "``run(\"cmd\", pty=True, combine_stderr=False)``: valid, but won't really make much of a difference, as ``pty=True`` will still result in merged streams. May be useful for avoiding any edge case problems in ``combine_stderr`` (none are presently known)."
msgstr ""

