#
msgid ""
msgstr ""
"Project-Id-Version: Fabric 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-15 23:24+0900\n"
"PO-Revision-Date: 2014-03-21 20:07+0900\n"
"Last-Translator: JOTAKI, Taisuke <tekapo@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Language: ja\n"
"X-Generator: Poedit 1.6.4\n"

#: ../../usage/execution.rst:3
msgid "Execution model"
msgstr "実行モデル"

#: ../../usage/execution.rst:5
msgid ""
"If you've read the :doc:`../tutorial`, you should already be familiar with "
"how Fabric operates in the base case (a single task on a single host.) "
"However, in many situations you'll find yourself wanting to execute multiple "
"tasks and/or on multiple hosts. Perhaps you want to split a big task into "
"smaller reusable parts, or crawl a collection of servers looking for an old "
"user to remove. Such a scenario requires specific rules for when and how "
"tasks are executed."
msgstr ""
":doc:`../tutorial` をすでに読んでいるのなら、Fabricが基本的なケース(単一のホ"
"ストに対する単一のタスク)でどのように動作するのかお分かりかと思います。しか"
"し、多くの場合、複数のタスクおよび/または複数のホストに対する実行を望むことで"
"しょう。大きなタスクを小さくて再利用可能なパーツに分けたり、一群のサーバで古"
"いユーザを削除したりすることを望むかと思います。そのようなシナリオでは、い"
"つ、どのようにタスクを実行するかの特定のルールが必要になってきます。"

#: ../../usage/execution.rst:12
msgid ""
"This document explores Fabric's execution model, including the main "
"execution loop, how to define host lists, how connections are made, and so "
"forth."
msgstr ""
"このドキュメントではFabricの実行モデルを説明します。メインの実行ループ、ホス"
"トリストの定義方法、どのように接続が行われるかなどが含まれています。"

#: ../../usage/execution.rst:19
msgid "Execution strategy"
msgstr "実行ストラテジー"

#: ../../usage/execution.rst:21
msgid ""
"Fabric defaults to a single, serial execution method, though there is an "
"alternative parallel mode available as of Fabric 1.3 (see :doc:`/usage/"
"parallel`). This default behavior is as follows:"
msgstr ""
"デフォルトでは、Fabricは単一でシリアルな実行メソッドです。ただし、Fabric 1.3"
"からはパラレルモードも利用できるようになっています( :doc:`/usage/parallel` 参"
"照)。このデフォルトの挙動は次のようになっています:"

#: ../../usage/execution.rst:25
msgid ""
"A list of tasks is created. Currently this list is simply the arguments "
"given to :doc:`fab <fab>`, preserving the order given."
msgstr ""
"タスクの一覧が作成されます。この時点ではこのリストは単に :doc:`fab <fab>` に"
"与えられた引数で、与えられた順番も保持します。"

#: ../../usage/execution.rst:27
msgid ""
"For each task, a task-specific host list is generated from various sources "
"(see :ref:`host-lists` below for details.)"
msgstr ""
"さまざまなソースから、各タスクごとにタスク用のホストリストが生成されます(詳細"
"は :ref:`host-lists` を参照)。"

#: ../../usage/execution.rst:29
msgid ""
"The task list is walked through in order, and each task is run once per host "
"in its host list."
msgstr ""
"タスクリストが順番に実行され、各タスクはホストリストの各ホストごとに一度づつ"
"実行されます。"

#: ../../usage/execution.rst:31
msgid ""
"Tasks with no hosts in their host list are considered local-only, and will "
"always run once and only once."
msgstr ""
"ホストリストにホストのないタスクはローカルのみと判断され、常に一度のみしか実"
"行されません。"

#: ../../usage/execution.rst:34
msgid "Thus, given the following fabfile::"
msgstr "したがって、次のfabfileが実行されると::"

#: ../../usage/execution.rst:46
msgid "and the following invocation::"
msgstr "次のように起動されます::"

#: ../../usage/execution.rst:50
msgid "you will see that Fabric performs the following:"
msgstr "そして、次のようにFabricが実行します:"

#: ../../usage/execution.rst:52
msgid "``taskA`` executed on ``host1``"
msgstr "``taskA`` を ``host1`` に対して実行"

#: ../../usage/execution.rst:53
msgid "``taskA`` executed on ``host2``"
msgstr "``taskA`` を ``host2`` に対して実行"

#: ../../usage/execution.rst:54
msgid "``taskB`` executed on ``host1``"
msgstr "``taskB`` を ``host1`` に対して実行"

#: ../../usage/execution.rst:55
msgid "``taskB`` executed on ``host2``"
msgstr "``taskB`` を ``host2`` に対して実行"

#: ../../usage/execution.rst:57
msgid ""
"While this approach is simplistic, it allows for a straightforward "
"composition of task functions, and (unlike tools which push the multi-host "
"functionality down to the individual function calls) enables shell script-"
"like logic where you may introspect the output or return code of a given "
"command and decide what to do next."
msgstr ""
"このアプローチはとても単純なものですが、タスク機能の分かりやすい構成を可能に"
"し、(マルチホスト機能を個々の関数呼び出しに落としこむような他のツールとは地"
"gって)出力を内省したり、与えられたコマンドのコードを返して、次に何をするか決"
"定したりできるシェルスクリプトのようなロジックを可能にします。"

#: ../../usage/execution.rst:65
msgid "Defining tasks"
msgstr "タスクの定義"

#: ../../usage/execution.rst:67
msgid ""
"For details on what constitutes a Fabric task and how to organize them, "
"please see :doc:`/usage/tasks`."
msgstr ""
"Fabricタスクの構成や構造化についての詳細はを :doc:`/usage/tasks` ご覧くださ"
"い。"

#: ../../usage/execution.rst:71
msgid "Defining host lists"
msgstr "ホストリストの定義"

#: ../../usage/execution.rst:73
msgid ""
"Unless you're using Fabric as a simple build system (which is possible, but "
"not the primary use-case) having tasks won't do you any good without the "
"ability to specify remote hosts on which to execute them. There are a number "
"of ways to do so, with scopes varying from global to per-task, and it's "
"possible mix and match as needed."
msgstr ""
"Fabricを単一のビルドシステムとして使うのでなければ(可能ですが、主なユースケー"
"スではありません)、特定のリモートホストに対してタスクを実行できなければ、役立"
"たずでしょう。Fabricでは、ホストを指定する方法がたくさんあります。グローバル"
"からタスクごとまでのスコープで、また、必要に応じて組み合わせたり、マッチさせ"
"たりすることもできます。"

#: ../../usage/execution.rst:82
msgid "Hosts"
msgstr "ホスト"

#: ../../usage/execution.rst:84
msgid ""
"Hosts, in this context, refer to what are also called \"host strings\": "
"Python strings specifying a username, hostname and port combination, in the "
"form of ``username@hostname:port``. User and/or port (and the associated "
"``@`` or ``:``) may be omitted, and will be filled by the executing user's "
"local username, and/or port 22, respectively. Thus, ``admin@foo.com:222``, "
"``deploy@website`` and ``nameserver1`` could all be valid host strings."
msgstr ""
"ここでは、ホストとは \"ホスト文字列\" で、ユーザー名、ホスト名、ポートを "
"``username@hostname:port`` の形式で組み合わせたPythonの文字列のことを指しま"
"す。ユーザーおよび/またはポート(と関連付けられた ``@`` もしくは ``:`` )は省略"
"可能で、その場合は実行ユーザーのローカルのユーザー名および/もしくはポート22が"
"それぞれ利用されます。したがって、``admin@foo.com:222``、``deploy@website``、"
"``nameserver1`` はいずれも有効なホスト文字列です。"

#: ../../usage/execution.rst:91
msgid ""
"IPv6 address notation is also supported, for example ``::1``, "
"``[::1]:1222``, ``user@2001:db8::1`` or ``user@[2001:db8::1]:1222``. Square "
"brackets are necessary only to separate the address from the port number. If "
"no port number is used, the brackets are optional. Also if host string is "
"specified via command-line argument, it may be necessary to escape brackets "
"in some shells."
msgstr ""
"IPv6アドレスのノーテーション、例えば ``::1``、 ``[::1]:1222``, ``user@2001:"
"db8::1``、 ``user@[2001:db8::1]:1222`` もサポートしています。角括弧はアドレス"
"とポート番号を別にするときだけ必要です。ポート番号を使用しないのなら、角括弧"
"は任意です。また、コマンドラインの引数経由でホスト文字列を指定でき、その場合"
"は、シェルに寄ってはカッコをエスケープする必要が出てくるかもしれません。"

#: ../../usage/execution.rst:99
msgid ""
"The user/hostname split occurs at the last ``@`` found, so e.g. email "
"address usernames are valid and will be parsed correctly."
msgstr ""
"ユーザー/ホスト名は最後に見つかった ``@`` で分割されます。したがって、メール"
"アドレスでのユーザー名も有効で、正しくパースされます。"

#: ../../usage/execution.rst:102
msgid ""
"During execution, Fabric normalizes the host strings given and then stores "
"each part (username/hostname/port) in the environment dictionary, for both "
"its use and for tasks to reference if the need arises. See :doc:`env` for "
"details."
msgstr ""
"実行中、Fabricは与えられたホスト文字列を正規化し、各部分(ユーザー名/ホスト名/"
"ポート)を環境辞書に保存し、必要なときにタスクが参照します。詳細は :doc:`env` "
"を参照してください。"

#: ../../usage/execution.rst:109
msgid "Roles"
msgstr "ロール"

#: ../../usage/execution.rst:111
msgid ""
"Host strings map to single hosts, but sometimes it's useful to arrange hosts "
"in groups. Perhaps you have a number of Web servers behind a load balancer "
"and want to update all of them, or want to run a task on \"all client servers"
"\". Roles provide a way of defining strings which correspond to lists of "
"host strings, and can then be specified instead of writing out the entire "
"list every time."
msgstr ""
"ホスト文字列は単一のホストにマップされますが、ホストをグループで用意したほう"
"が都合のいい場合もあるでしょう。例えば、ロードバランサーの後ろにたくさんのWeb"
"サーバがあって、それをすべてアップデートしたい場合や \"クライアントのすべての"
"サーバ\" にタスクを実行したい場合です。ロールは、ホスト文字列のリストに対応し"
"た文字列を定義できる手段を提供します。これにより、毎回ホストリスト全体を書き"
"出す代わりに、この文字列を指定することができます。"

#: ../../usage/execution.rst:118
msgid ""
"This mapping is defined as a dictionary, ``env.roledefs``, which must be "
"modified by a fabfile in order to be used. A simple example::"
msgstr ""
"このマッピングは辞書 ``env.roledefs`` として定義され、利用するためにはfabfile"
"内で指定する必要があります。例えば::"

#: ../../usage/execution.rst:125
msgid ""
"Since ``env.roledefs`` is naturally empty by default, you may also opt to re-"
"assign to it without fear of losing any information (provided you aren't "
"loading other fabfiles which also modify it, of course)::"
msgstr ""
"``env.roledefs`` は当然ながらデフォルトでは空なので、どんな情報も失うおそれな"
"く再割当てすることができます(もちろんこれを指定している他のfabfileを読み込ま"
"なければ)::"

#: ../../usage/execution.rst:136
msgid ""
"In addition to list/iterable object types, the values in ``env.roledefs`` "
"may be callables, and will thus be called when looked up when tasks are run "
"instead of at module load time. (For example, you could connect to remote "
"servers to obtain role definitions, and not worry about causing delays at "
"fabfile load time when calling e.g. ``fab --list``.)"
msgstr ""
"リスト/反復可能なオブジェクトタイプに加えて、 ``env.roledefs`` の値は呼び出し"
"可能で、"

#: ../../usage/execution.rst:142
msgid ""
"Use of roles is not required in any way -- it's simply a convenience in "
"situations where you have common groupings of servers."
msgstr ""
"ロールの使用は必須ではありません。サーバーの一般的なグループ化をするときに便"
"利なようにしているだけです。"

#: ../../usage/execution.rst:145
msgid "Added ability to use callables as ``roledefs`` values."
msgstr "``roledefs`` の値として呼び出し可能な機能を追加。"

#: ../../usage/execution.rst:151
msgid "How host lists are constructed"
msgstr "ホストリストがどのように作られるか"

#: ../../usage/execution.rst:153
msgid ""
"There are a number of ways to specify host lists, either globally or per-"
"task, and generally these methods override one another instead of merging "
"together (though this may change in future releases.) Each such method is "
"typically split into two parts, one for hosts and one for roles."
msgstr ""
"ホストリストを指定する方法は全体であれ、タスクごとであれ、たくさんあります。"
"またたいていの場合、これらの方法はマージするのではなくそれぞれの方法をオー"
"バーライドできます(将来のリリースでは変更されるかもしれませんが)。これらの各"
"方法は主に2つの部分、ホスト用とロール用に分けられます。"

#: ../../usage/execution.rst:159
msgid "Globally, via ``env``"
msgstr "``env`` 経由でグローバルに"

#: ../../usage/execution.rst:161
msgid ""
"The most common method of setting hosts or roles is by modifying two key-"
"value pairs in the environment dictionary, :doc:`env <env>`: ``hosts`` and "
"``roles``. The value of these variables is checked at runtime, while "
"constructing each tasks's host list."
msgstr ""
"ホストもしくはロールを設定するいちばん一般的な方法は環境辞書 :doc:`env "
"<env>`: ``hosts`` と ``roles`` に2つのキーバリューペアを設定する方法です。こ"
"れらの変数の値は起動時、各タスクのホストリスト作成中にチェックされます。"

#: ../../usage/execution.rst:166
msgid ""
"Thus, they may be set at module level, which will take effect when the "
"fabfile is imported::"
msgstr ""
"したがって、これらの値はモジュールレベルで設定され、fabfileのインポート時に有"
"効になります::"

#: ../../usage/execution.rst:176
msgid ""
"Such a fabfile, run simply as ``fab mytask``, will run ``mytask`` on "
"``host1`` followed by ``host2``."
msgstr ""
"単に ``fab mytask`` として動作させるこのようなfabfileの場合、 ``mytask`` が "
"``host1`` に対して、続いて ``host2`` に対して実行されます。"

#: ../../usage/execution.rst:179
msgid ""
"Since the env vars are checked for *each* task, this means that if you have "
"the need, you can actually modify ``env`` in one task and it will affect all "
"following tasks::"
msgstr ""
"env変数は **各タスク** でチェックされるので、必要に応じてタスク内で ``env`` "
"を変更することができ、その変更はその後に続くタスクにも反映されます。"

#: ../../usage/execution.rst:191
msgid ""
"When run as ``fab set_hosts mytask``, ``set_hosts`` is a \"local\" task -- "
"its own host list is empty -- but ``mytask`` will again run on the two hosts "
"given."
msgstr ""
"``fab set_hosts mytask`` として実行すると、 ``set_hosts`` はホストリストがか"
"らのため \"local\" タスクとなりますが、 ``mytask`` は与えられた2つのホストに"
"対して再び実行されます。"

#: ../../usage/execution.rst:196
msgid ""
"This technique used to be a common way of creating fake \"roles\", but is "
"less necessary now that roles are fully implemented. It may still be useful "
"in some situations, however."
msgstr ""
"この手法は見せかけの \"roles\" の作成方法としてよく利用されていましたが、ロー"
"ル機能が完全に実装されたので今は必要性が少なくなりました。とは言え、場合に"
"よっては今でも便利な方法です。"

#: ../../usage/execution.rst:200
msgid ""
"Alongside ``env.hosts`` is ``env.roles`` (not to be confused with ``env."
"roledefs``!) which, if given, will be taken as a list of role names to look "
"up in ``env.roledefs``."
msgstr ""
"``env.hosts`` と同じように、 ``env.roles`` (``env.roledefs`` と間違えによう"
"に!)が与えられると、``env.roledefs`` 内を探すためにロール名のリストとして扱わ"
"れます。"

#: ../../usage/execution.rst:205
msgid "Globally, via the command line"
msgstr "コマンドライン経由でグローバルに"

#: ../../usage/execution.rst:207
msgid ""
"In addition to modifying ``env.hosts``, ``env.roles``, and ``env."
"exclude_hosts`` at the module level, you may define them by passing comma-"
"separated string arguments to the command-line switches :option:`--hosts/-H "
"<-H>` and :option:`--roles/-R <-R>`, e.g.::"
msgstr ""
"モジュールレベルでの ``env.hosts``、``env.roles``、``env.exclude_hosts`` の設"
"定に加え、コンマで分けた文字列引数としてコマンドラインのスイッチ :option:`--"
"hosts/-H <-H>` と :option:`--roles/-R <-R>` に渡すことでもこれらの設定が可能"
"です。::"

#: ../../usage/execution.rst:214
msgid ""
"Such an invocation is directly equivalent to ``env.hosts = ['host1', "
"'host2']`` -- the argument parser knows to look for these arguments and will "
"modify ``env`` at parse time."
msgstr ""
"こうした実行は ``env.hosts = ['host1', 'host2']`` と同等で、引数パーサーはこ"
"れらの引数を探し、パース時に ``env`` を設定します。"

#: ../../usage/execution.rst:220
msgid ""
"It's possible, and in fact common, to use these switches to set only a "
"single host or role. Fabric simply calls ``string.split(',')`` on the given "
"string, so a string with no commas turns into a single-item list."
msgstr ""
"これらのスイッチを単一のホストやロールを設定するためだけに利用するのは、可能"
"ですし、たしかに一般的です。Fabricは、与えられた文字列に対して ``string."
"split(',')`` を単に呼び出しているだけで、コンマがない文字列は単一のアイテムリ"
"ストとして扱われます。"

#: ../../usage/execution.rst:224
msgid ""
"It is important to know that these command-line switches are interpreted "
"**before** your fabfile is loaded: any reassignment to ``env.hosts`` or "
"``env.roles`` in your fabfile will overwrite them."
msgstr ""
"これらのコマンドラインスイッチは、fabfileが **読み込まれる前** に解釈されると"
"いうことは重要なので、これに留意してください。つまり、fabfile内の ``env."
"hosts`` もしくは ``env.roles`` で再割当てされた値がこれらのスイッチを上書きす"
"るのです。"

#: ../../usage/execution.rst:228
msgid ""
"If you wish to nondestructively merge the command-line hosts with your "
"fabfile-defined ones, make sure your fabfile uses ``env.hosts.extend()`` "
"instead::"
msgstr ""
"コマンドラインのホストとfabfileで指定されたホストの非破壊的なマージをしたい場"
"合は、fabfileで ``env.hosts.extend()`` を使うようにしてください::"

#: ../../usage/execution.rst:239
msgid ""
"When this fabfile is run as ``fab -H host1,host2 mytask``, ``env.hosts`` "
"will then contain ``['host1', 'host2', 'host3', 'host4']`` at the time that "
"``mytask`` is executed."
msgstr ""
"このfabfileを ``fab -H host1,host2 mytask`` として起動すると、 ``mytask`` の"
"実行時に ``['host1', 'host2', 'host3', 'host4']`` が ``env.hosts`` に含まれま"
"す。"

#: ../../usage/execution.rst:245
msgid ""
"``env.hosts`` is simply a Python list object -- so you may use ``env.hosts."
"append()`` or any other such method you wish."
msgstr ""
"``env.hosts`` は単なるPythonのリストオブジェクトなので ``env.hosts."
"append()`` やその他のメソッドも使うことができます。"

#: ../../usage/execution.rst:251
msgid "Per-task, via the command line"
msgstr "コマンドライン経由でタスクごとに"

#: ../../usage/execution.rst:253
msgid ""
"Globally setting host lists only works if you want all your tasks to run on "
"the same host list all the time. This isn't always true, so Fabric provides "
"a few ways to be more granular and specify host lists which apply to a "
"single task only. The first of these uses task arguments."
msgstr ""
"いつも同じホストリストに対してすべてのタスクを実行したいのなら、グローバルに"
"ホストリストを設定するといいでしょう。しかし常にそうとは限らないので、Fabric"
"はより粒度の細かい方法をいくつか提供していて、単一のタスクのみに適用されるホ"
"ストリストを指定することができます。最初の方法はタスク引数を利用する方法で"
"す。"

#: ../../usage/execution.rst:258
msgid ""
"As outlined in :doc:`fab`, it's possible to specify per-task arguments via a "
"special command-line syntax. In addition to naming actual arguments to your "
"task function, this may be used to set the ``host``, ``hosts``, ``role`` or "
"``roles`` \"arguments\", which are interpreted by Fabric when building host "
"lists (and removed from the arguments passed to the task itself.)"
msgstr ""
":doc:`fab` でも説明したように、特別なコマンドラインシンタックスによってタスク"
"ごとに引数を指定できます。タスク機能に実際に引数を設定できるのに加え、"
"``host``、 ``hosts``、 ``role``、 ``roles`` \"引数\" をセットするのに使われま"
"す。これはホストリストの組み立て時にFabricによって解釈されます(そして、タスク"
"に渡された引数から取り除かれます)。"

#: ../../usage/execution.rst:266
msgid ""
"Since commas are already used to separate task arguments from one another, "
"semicolons must be used in the ``hosts`` or ``roles`` arguments to delineate "
"individual host strings or role names. Furthermore, the argument must be "
"quoted to prevent your shell from interpreting the semicolons."
msgstr ""
"コンマはすでにタスク引数の分割に使われているので、各ホスト文字列やロール名の"
"設定にはそれぞれの ``hosts`` もしくは ``roles`` 引数でセミコロンを使う必要が"
"あります。さらに、シェルがセミコロンを解釈しないように引数はクォートされてい"
"なければなりません。"

#: ../../usage/execution.rst:271
msgid ""
"Take the below fabfile, which is the same one we've been using, but which "
"doesn't define any host info at all::"
msgstr ""
"以下のfabfileを見てみると、これまで使っていたものと同じですが、ホストの情報は"
"まったく設定されていません::"

#: ../../usage/execution.rst:279
msgid "To specify per-task hosts for ``mytask``, execute it like so::"
msgstr ""
"``mytast`` 用のタスクごとのホストを指定するには、以下のように実行します::"

#: ../../usage/execution.rst:283
msgid ""
"This will override any other host list and ensure ``mytask`` always runs on "
"just those two hosts."
msgstr ""
"これはどんなホストリストも上書きし、``mytask`` は常にこの2つのホストに対して"
"実行されます。"

#: ../../usage/execution.rst:287
msgid "Per-task, via decorators"
msgstr "デコレーター経由でタスクごとに"

#: ../../usage/execution.rst:289
msgid ""
"If a given task should always run on a predetermined host list, you may wish "
"to specify this in your fabfile itself. This can be done by decorating a "
"task function with the `~fabric.decorators.hosts` or `~fabric.decorators."
"roles` decorators. These decorators take a variable argument list, like so::"
msgstr ""
"与えられたタスクが常に事前に定義されたホストリストに対して実行される場合は、"
"fabfile内でのこのリストの指定を望むことでしょう。これは `~fabric.decorators."
"hosts` もしくは `~fabric.decorators.roles` デコレータでタスク関数をデコレート"
"することで可能です。これらのデコレータは変数引数リストをとります。例えば::"

#: ../../usage/execution.rst:300
msgid "They will also take an single iterable argument, e.g.::"
msgstr "これは、繰り返し可能な単一の引数を取ることもできます。例えば::"

#: ../../usage/execution.rst:307
msgid ""
"When used, these decorators override any checks of ``env`` for that "
"particular task's host list (though ``env`` is not modified in any way -- it "
"is simply ignored.) Thus, even if the above fabfile had defined ``env."
"hosts`` or the call to :doc:`fab <fab>` uses :option:`--hosts/-H <-H>`, "
"``mytask`` would still run on a host list of ``['host1', 'host2']``."
msgstr ""
"これが利用されると、このデコレータはこの特定のタスクのホストリスト用の "
"``env`` のチェックをオーバーライドします(``env`` が変更されるわけではありませ"
"ん。単に無視されます)。そして、たとえ上記fabfileで ``env.hosts`` が指定されて"
"いたり :doc:`fab <fab>` が :option:`--hosts/-H <-H>` を使っていても "
"``mytask`` は ``['host1', 'host2']`` のホストリストに対して実行されます。"

#: ../../usage/execution.rst:313
msgid ""
"However, decorator host lists do **not** override per-task command-line "
"arguments, as given in the previous section."
msgstr ""
"とは言え、デコレータのホストリストは、上のセクションで説明したタスクごとのコ"
"マンドラインを **上書きすることはありません**。"

#: ../../usage/execution.rst:317
msgid "Order of precedence"
msgstr "優先順位"

#: ../../usage/execution.rst:319
msgid ""
"We've been pointing out which methods of setting host lists trump the "
"others, as we've gone along. However, to make things clearer, here's a quick "
"breakdown:"
msgstr ""
"ここまで、ホストリスト設定のどの方法が他の方法よりも優先するかについて説明し"
"てきました。もっと明確にするため、以下に簡単にまとめます:"

#: ../../usage/execution.rst:322
msgid ""
"Per-task, command-line host lists (``fab mytask:host=host1``) override "
"absolutely everything else."
msgstr ""
"タスクごとのコマンドラインホストリスト(``fab mytask:host=host1``)は他のすべて"
"を完全にオーバーライドする。"

#: ../../usage/execution.rst:324
msgid ""
"Per-task, decorator-specified host lists (``@hosts('host1')``) override the "
"``env`` variables."
msgstr ""
"タスクごとのデコレータで指定されたホストリスト(``@hosts('host1')``)は "
"``env`` 変数をオーバーライドする。"

#: ../../usage/execution.rst:326
msgid ""
"Globally specified host lists set in the fabfile (``env.hosts = ['host1']``) "
"*can* override such lists set on the command-line, but only if you're not "
"careful (or want them to.)"
msgstr ""
"fabfileでグローバルに指定されたホストリスト(``env.hosts = ['host1']``)はコマ"
"ンドラインでのホストリストをオーバーライド *できる* が、それは自分が注意して"
"いない場合(もしくは意図的に行った場合)のみ。"

#: ../../usage/execution.rst:329
msgid ""
"Globally specified host lists set on the command-line (``--hosts=host1``) "
"will initialize the ``env`` variables, but that's it."
msgstr ""
"コマンドラインでグローバルに設定されたホストリストは(``--hosts=host1``) "
"``env`` 変数を初期化するが、それだけしかしない。"

#: ../../usage/execution.rst:332
msgid ""
"This logic may change slightly in the future to be more consistent (e.g. "
"having :option:`--hosts <-H>` somehow take precedence over ``env.hosts`` in "
"the same way that command-line per-task lists trump in-code ones) but only "
"in a backwards-incompatible release."
msgstr ""
"この優先順位はより一貫性を持たせるために将来的には少し変更されるかもしれませ"
"ん(例えば、コマンドラインのタスクごとのリストがコード内のリストに優先されるの"
"と同じように :option:`--hosts <-H>` が ``env.hosts`` より優先される)が、それ"
"は後方互換性リリースの時だけです。"

#: ../../usage/execution.rst:340
msgid "Combining host lists"
msgstr "ホストリストの結合"

#: ../../usage/execution.rst:342
msgid ""
"There is no \"unionizing\" of hosts between the various sources mentioned "
"in :ref:`host-lists`. If ``env.hosts`` is set to ``['host1', 'host2', "
"'host3']``, and a per-function (e.g.  via `~fabric.decorators.hosts`) host "
"list is set to just ``['host2', 'host3']``, that function will **not** "
"execute on ``host1``, because the per-task decorator host list takes "
"precedence."
msgstr ""
":ref:`host-lists` で言及している様々なソース間のホストを \"結合\" する方法は"
"ありません。もし ``env.hosts`` が ``['host1', 'host2', 'host3']`` に設定され"
"ていて、関数ごと(例えば `~fabric.decorators.hosts` 経由)のホストリストが "
"``['host2', 'host3']`` と設定されている場合、この関数は ``host1`` に対しては "
"**実行されません** 。タスクごとのデコレータホストリストがの方が優先されるから"
"です。"

#: ../../usage/execution.rst:348
msgid ""
"However, for each given source, if both roles **and** hosts are specified, "
"they will be merged together into a single host list. Take, for example, "
"this fabfile where both of the decorators are used::"
msgstr ""
"とは言え、与えられた各ソースでは、もしロールとホストの **両方** が設定された"
"場合、両方ともひとつのホストリストにマージされます。例えば、以下のように両方"
"のデコレータが使われているfabfileを見てみましょう::"

#: ../../usage/execution.rst:361
msgid ""
"Assuming no command-line hosts or roles are given when ``mytask`` is "
"executed, this fabfile will call ``mytask`` on a host list of ``['a', 'b', "
"'c']`` -- the union of ``role1`` and the contents of the `~fabric.decorators."
"hosts` call."
msgstr ""
"``mytask`` 実行時にはコマンドラインのホストやロールが与えられていないとする"
"と、このfabfileは ``role1`` と `~fabric.decorators.hosts` 呼び出しの中身の結"
"合されたホストリスト ``['a', 'b', 'c']`` に対して ``mytask`` を実行します。"

#: ../../usage/execution.rst:369
msgid "Host list deduplication"
msgstr "ホストリストの重複"

#: ../../usage/execution.rst:371
msgid ""
"By default, to support :ref:`combining-host-lists`, Fabric deduplicates the "
"final host list so any given host string is only present once. However, this "
"prevents explicit/intentional running of a task multiple times on the same "
"target host, which is sometimes useful."
msgstr ""
"デフォルトでは、 :ref:`combining-host-lists` をサポートするためFabricは最終的"
"なホストリストから重複を取り除くので、与えられるどのホスト文字列も一度だけし"
"か対象になりません。とは言え、これでは有益なこともある同じターゲットホストに"
"対して明示的/意図的な複数回タスクの実行ができません。"

#: ../../usage/execution.rst:376
msgid ""
"To turn off deduplication, set :ref:`env.dedupe_hosts <dedupe_hosts>` to "
"``False``."
msgstr ""
"重複除去の機能を無効にするには :ref:`env.dedupe_hosts <dedupe_hosts>` を "
"``False`` にします。"

#: ../../usage/execution.rst:383
msgid "Excluding specific hosts"
msgstr "特定のホストの除外"

#: ../../usage/execution.rst:385
msgid ""
"At times, it is useful to exclude one or more specific hosts, e.g. to "
"override a few bad or otherwise undesirable hosts which are pulled in from a "
"role or an autogenerated host list."
msgstr ""
"時には、ひとつもしくは複数の特定のホストを除外すると便利な時もあります。例え"
"ば、あるロールや自動的に生成されたホストリストから引き出されるいくつかの必要"
"のないホストをオーバーライドする場合などです。"

#: ../../usage/execution.rst:390
msgid ""
"As of Fabric 1.4, you may wish to use :ref:`skip-bad-hosts` instead, which "
"automatically skips over any unreachable hosts."
msgstr ""
"Fabric 1.4 からは接続できなかったホストをスキップする :ref:`skip-bad-hosts` "
"を使うこともできます。"

#: ../../usage/execution.rst:393
msgid ""
"Host exclusion may be accomplished globally with :option:`--exclude-hosts/-x "
"<-x>`::"
msgstr ""
"グローバルでは :option:`--exclude-hosts/-x <-x>` でホストの除外ができます::"

#: ../../usage/execution.rst:398
msgid ""
"If ``myrole`` was defined as ``['host1', 'host2', ..., 'host15']``, the "
"above invocation would run with an effective host list of ``['host1', "
"'host3', 'host4', 'host6', ..., 'host15']``."
msgstr ""
"``myrole`` が ``['host1', 'host2', ..., 'host15']`` として定義されている場"
"合、上のように実行すると、有効なホストリスト ``['host1', 'host3', 'host4', "
"'host6', ..., 'host15']`` となります。"

#: ../../usage/execution.rst:403
msgid ""
"Using this option does not modify ``env.hosts`` -- it only causes the main "
"execution loop to skip the requested hosts."
msgstr ""
"このオプションを利用しても ``env.hosts`` は修正されません。メインの実行ループ"
"がリクエストされたホストをスキップするだけです。"

#: ../../usage/execution.rst:406
msgid ""
"Exclusions may be specified per-task by using an extra ``exclude_hosts`` "
"kwarg, which is implemented similarly to the abovementioned ``hosts`` and "
"``roles`` per-task kwargs, in that it is stripped from the actual task "
"invocation. This example would have the same result as the global exclude "
"above::"
msgstr ""
"除外は、付加的な ``exclude_hosts`` 引数を利用することでタスクごとに指定するこ"
"ともできます。これは、上記で言及したタスクごとの ``hosts`` と ``roles`` 引数"
"と同じように実装されていて、実際のタスク実行にストリップされます。以下の例で"
"は、上記のグローバル除外と同じ結果になります::"

#: ../../usage/execution.rst:413
msgid ""
"Note that the host list is semicolon-separated, just as with the ``hosts`` "
"per-task argument."
msgstr ""
"ホストリストはタスクごと引数の ``hosts`` と同じようにセミコロンで分けられま"
"す。"

#: ../../usage/execution.rst:417
msgid "Combining exclusions"
msgstr "除外の結合"

#: ../../usage/execution.rst:419
msgid ""
"Host exclusion lists, like host lists themselves, are not merged together "
"across the different \"levels\" they can be declared in. For example, a "
"global ``-x`` option will not affect a per-task host list set with a "
"decorator or keyword argument, nor will per-task ``exclude_hosts`` keyword "
"arguments affect a global ``-H`` list."
msgstr ""
"ホスト除外リストは、ホストリスト自身と同じように、宣言されている \"levels\" "
"が違うリスト間ではマージされません。例えば、グローバルな ``-x`` オプション"
"は、デコレータやキーワード引数でセットされたタスクごとのホストリストに影響し"
"ません。また、タスクごとの ``exclude_hosts`` キーワード引数もグローバルな ``-"
"H`` リストに影響しません。"

#: ../../usage/execution.rst:425
msgid ""
"There is one minor exception to this rule, namely that CLI-level keyword "
"arguments (``mytask:exclude_hosts=x,y``) **will** be taken into account when "
"examining host lists set via ``@hosts`` or ``@roles``. Thus a task function "
"decorated with ``@hosts('host1', 'host2')`` executed as ``fab taskname:"
"exclude_hosts=host2`` will only run on ``host1``."
msgstr ""
"このルールにはひとつだけ小さな例外があります。``@hosts`` もしくは ``@roles`` "
"経由でのホストリストの分析時に、CLIレベルのキーワード引数(``mytask:"
"exclude_hosts=x,y``)が取り入れられます。したがって、 ``@hosts('host1', "
"'host2')`` でデコレートされているタスク関数が ``fab taskname:"
"exclude_hosts=host2`` として実行されると、 ``host1`` だけに対してのみ実行され"
"ます。"

#: ../../usage/execution.rst:431
msgid ""
"As with the host list merging, this functionality is currently limited "
"(partly to keep the implementation simple) and may be expanded in future "
"releases."
msgstr ""
"ホストリストのマージに関しては、現行では機能は限定的(実装をシンプルに保つため"
"でもあります)で、将来のリリースでは拡張されるかもしれません。"

#: ../../usage/execution.rst:438
msgid "Intelligently executing tasks with ``execute``"
msgstr "``execute`` での賢いタスクの実行"

#: ../../usage/execution.rst:442
msgid ""
"Most of the information here involves \"top level\" tasks executed via :doc:"
"`fab <fab>`, such as the first example where we called ``fab taskA taskB``. "
"However, it's often convenient to wrap up multi-task invocations like this "
"into their own, \"meta\" tasks."
msgstr ""
"ここの情報のほとんどは、最初の例で ``fab taskA taskB`` を呼び出したように、 :"
"doc:`fab <fab>` 経由で実行される \"トップレベル\" のタスクに作用します。とは"
"言え、以下の \"meta\" タスクのような複数タスクの実行をまとめたものも便利な時"
"があります。"

#: ../../usage/execution.rst:447
msgid ""
"Prior to Fabric 1.3, this had to be done by hand, as outlined in :doc:`/"
"usage/library`. Fabric's design eschews magical behavior, so simply "
"*calling* a task function does **not** take into account decorators such as "
"`~fabric.decorators.roles`."
msgstr ""
"Fabric 1.3以前は :doc:`/usage/library` で書かれていたように手動で行う必要があ"
"りました。Fabricのデザインは魔法的な挙動を避けているので、単純にタスクを *呼"
"び出しても* `~fabric.decorators.roles` のようなデコレータは考慮 **しません"
"** 。"

#: ../../usage/execution.rst:452
msgid ""
"New in Fabric 1.3 is the `~fabric.tasks.execute` helper function, which "
"takes a task object or name as its first argument. Using it is effectively "
"the same as calling the given task from the command line: all the rules "
"given above in :ref:`host-lists` apply. (The ``hosts`` and ``roles`` keyword "
"arguments to `~fabric.tasks.execute` are analogous to :ref:`CLI per-task "
"arguments <hosts-per-task-cli>`, including how they override all other host/"
"role-setting methods.)"
msgstr ""
"Fabric 1.3では新しく `~fabric.tasks.execute` ヘルパー関数が追加されました。こ"
"れは最初の引数としてタスクオブジェクトもしくはタスク名を取ります。コマンドラ"
"インから与えられたタスクを呼び出すのと同じくらい効率的に利用できます。上の :"
"ref:`host-lists` で与えられたすべてのルールが適用されます。( `~fabric.tasks."
"execute` への ``hosts`` と ``roles`` キーワード引数は、他のすべてのホスト/"
"ロール設定方法をオーバーライドする :ref:`CLIのタスクごとの引数 <hosts-per-"
"task-cli>` に類似しています)"

#: ../../usage/execution.rst:460
msgid ""
"As an example, here's a fabfile defining two stand-alone tasks for deploying "
"a Web application::"
msgstr ""
"例として、ウェブアプリケーションをデプロイする2つの別個に定義されたfabfileを"
"あげます。"

#: ../../usage/execution.rst:480
msgid ""
"In Fabric <=1.2, the only way to ensure that ``migrate`` runs on the DB "
"servers and that ``update`` runs on the Web servers (short of manual ``env."
"host_string`` manipulation) was to call both as top level tasks::"
msgstr ""
"Fabric <=1.2では、``migrate`` をDBサーバに対して確実に実行し、``update`` を"
"Webサーバに対して確実に実行する唯一の方法( ``env.host_string`` 操作の短いマ"
"ニュアル)は両方をトップレベルのタスクとして呼び出す方法しかありませんでした::"

#: ../../usage/execution.rst:486
msgid ""
"Fabric >=1.3 can use `~fabric.tasks.execute` to set up a meta-task. Update "
"the ``import`` line like so::"
msgstr ""
"Fabric >=1.3ではメタタスクのセットアップに `~fabric.tasks.execute` が使えま"
"す。 ``import`` の行を以下のようにします::"

#: ../../usage/execution.rst:491
msgid "and append this to the bottom of the file::"
msgstr "そして、ファイルの最後に次を追加します::"

#: ../../usage/execution.rst:497
msgid ""
"That's all there is to it; the `~fabric.decorators.roles` decorators will be "
"honored as expected, resulting in the following execution sequence:"
msgstr ""
"これだけです; `~fabric.decorators.roles` デコレータが期待通りに履行し、以下の"
"実行シーケンスの結果になります:"

#: ../../usage/execution.rst:499
msgid "`migrate` on `db1`"
msgstr "`db1` に対して `migrate`"

#: ../../usage/execution.rst:500
msgid "`migrate` on `db2`"
msgstr "`db2` に対して `migrate`"

#: ../../usage/execution.rst:501
msgid "`update` on `web1`"
msgstr "`web1` に対して `update`"

#: ../../usage/execution.rst:502
msgid "`update` on `web2`"
msgstr "`web2` に対して `update`"

#: ../../usage/execution.rst:503
msgid "`update` on `web3`"
msgstr "`web3` に対して `update`"

#: ../../usage/execution.rst:506
msgid ""
"This technique works because tasks that themselves have no host list (this "
"includes the global host list settings) only run one time. If used inside a "
"\"regular\" task that is going to run on multiple hosts, calls to `~fabric."
"tasks.execute` will also run multiple times, resulting in multiplicative "
"numbers of subtask calls -- be careful!"
msgstr ""
"このテクニックは、ホストリストを自分では持たないタスク(これにはグローバルなホ"
"ストリスト設定も含まれます)は一度しか実行されないので動作します。もし、複数ホ"
"ストに対して実行される \"通常の\" タスク内で利用された場合、`~fabric.tasks."
"execute` への呼び出しは複数回実行され、結果としてサブタスク呼び出しの倍数分実"
"行されるので、お気をつけて!"

#: ../../usage/execution.rst:512
msgid ""
"If you would like your `execute` calls to only be called once, you may use "
"the `~fabric.decorators.runs_once` decorator."
msgstr ""
"自分の `execute` 呼び出しを1度だけの呼び出しにするには `~fabric.decorators."
"runs_once` デコレータを使います。"

#: ../../usage/execution.rst:515
msgid "`~fabric.tasks.execute`, `~fabric.decorators.runs_once`"
msgstr "`~fabric.tasks.execute`, `~fabric.decorators.runs_once`"

#: ../../usage/execution.rst:521
msgid "Leveraging ``execute`` to access multi-host results"
msgstr "マルチホストの結果へのアクセスに ``execute`` を活用する"

#: ../../usage/execution.rst:523
msgid ""
"In nontrivial Fabric runs, especially parallel ones, you may want to gather "
"up a bunch of per-host result values at the end - e.g. to present a summary "
"table, perform calculations, etc."
msgstr ""
"Fabricの実行がひと仕事ある場合、特に並列にある場合、最後にたくさんあるホスト"
"ごとの結果の値を、例えばテーブルサマリーの表示や計算の実行をするためなど、ひ"
"とまとめにしたいことがあると思います。"

#: ../../usage/execution.rst:527
msgid ""
"It's not possible to do this in Fabric's default \"naive\" mode (one where "
"you rely on Fabric looping over host lists on your behalf), but with `."
"execute` it's pretty easy. Simply switch from calling the actual work-"
"bearing task, to calling a \"meta\" task which takes control of execution "
"with `.execute`::"
msgstr ""
"Fabricのデフォルトの \"ナイーブ\" モード(あなたが頼りにしている、ホストリスト"
"に対するあなたのために行うFabricの繰り返し処理のモードです)ではこれはできませ"
"んが、 `.execute` を使うととても簡単です。単純に実際の分割したタスクの呼び出"
"しから `.execute` との実行をコントロールする \"meta\" タスクの呼び出しにス"
"イッチします。"

#: ../../usage/execution.rst:544
msgid ""
"In the above, ``workhorse`` can do any Fabric stuff at all -- it's literally "
"your old \"naive\" task -- except that it needs to return something useful."
msgstr ""
"上の例では、 ``workhorse`` はFabricで可能なこと、文字通り古い \"naive\" なタ"
"スクはすべて可能です。なにか有益なことを返す必要がある時を除いてですが。"

#: ../../usage/execution.rst:547
msgid ""
"``go`` is your new entry point (to be invoked as ``fab go``, or whatnot) and "
"its job is to take the ``results`` dictionary from the `.execute` call and "
"do whatever you need with it. Check the API docs for details on the "
"structure of that return value."
msgstr ""
"``go`` は新しいエントリーポイント( ``fab go`` などとして実行されます)で、その"
"仕事は `.execute` 呼び出しから ``results`` 辞書を取り出し、それに対して必要な"
"ことをなんでもすることです。返り値の構造についての詳細はAPIドキュメントをご覧"
"ください。"

#: ../../usage/execution.rst:556
msgid "Using ``execute`` with dynamically-set host lists"
msgstr "ホストリストの動的セットとの ``execute`` の利用"

#: ../../usage/execution.rst:558
msgid ""
"A common intermediate-to-advanced use case for Fabric is to parameterize "
"lookup of one's target host list at runtime (when use of :ref:`execution-"
"roles` does not suffice). ``execute`` can make this extremely simple, like "
"so::"
msgstr ""
"実行時にターゲットホストリストの参照を並行で行うのはFabricの中級から上級のよ"
"くあるユースケースです( :ref:`execution-roles` の利用では十分ではない場合)。 "
"``execute`` は以下のようにこれをとても簡単に実現できます::"

#: ../../usage/execution.rst:583
msgid ""
"For example, if ``external_datastore`` was a simplistic \"look up hosts by "
"tag in a database\" service, and you wanted to run a task on all hosts "
"tagged as being related to your application stack, you might call the above "
"like this::"
msgstr ""
"例えば、 ``external_datastore`` が単純な \"データベース内をタグでホストをルッ"
"クアップ\" するサービスなら、そして自分のアプリケーション スタックに関連する"
"タグが付けられたすべてのホストに対してタスクを実行するのなら、上記を以下のよ"
"うに呼び出すことができます::"

#: ../../usage/execution.rst:589
msgid ""
"But wait! A data migration has gone awry on the DB servers. Let's fix up our "
"migration code in our source repo, and deploy just the DB boxes again::"
msgstr ""
"ちょっと待って! DBサーバ上のデータのマイグレーションがどっかに行ってしまいま"
"した。ソースリポジトリのマイグレーション用のコードを修正して、DBボックスだけ"
"に再度どプロイしてみましょう::"

#: ../../usage/execution.rst:594
msgid ""
"This use case looks similar to Fabric's roles, but has much more potential, "
"and is by no means limited to a single argument. Define the task however you "
"wish, query your external data store in whatever way you need -- it's just "
"Python."
msgstr ""
"このユースケースはロールに似ていますが、もっと潜在力があり、決してひとつの引"
"数だけに限定されるものでもありません。どのようにもタスクを定義でき、必要に応"
"じてどのようにも外部のデータストアにクエリーを行うことができます。結局のとこ"
"ろ、ただのPythonなのです。"

#: ../../usage/execution.rst:599
msgid "The alternate approach"
msgstr "別のアプローチ"

#: ../../usage/execution.rst:601
msgid ""
"Similar to the above, but using ``fab``'s ability to call multiple tasks in "
"succession instead of an explicit ``execute`` call, is to mutate :ref:`env."
"hosts <hosts>` in a host-list lookup task and then call ``do_work`` in the "
"same session::"
msgstr ""
"上記と似ているけれども、``execute`` 呼び出しを明示する代わりに ``fab`` の機能"
"を利用して連続で複数タスクを呼び出すには、ホストリストの参照タスクでの :ref:"
"`env.hosts <hosts>` を変化させ、同じセッションで ``do_work`` を呼び出します::"

#: ../../usage/execution.rst:621
msgid "Then invoke like so::"
msgstr "そして次のように実行されます::"

#: ../../usage/execution.rst:625
msgid ""
"One benefit of this approach over the previous one is that you can replace "
"``do_work`` with any other \"workhorse\" task::"
msgstr ""
"その前のアプローチと比べた時のこちらのアプローチの利点は ``do_work`` をどん"
"な \"workhorse\" タスクとも入れ替え可能ということです::"

#: ../../usage/execution.rst:636
msgid "Failure handling"
msgstr "失敗の扱い"

#: ../../usage/execution.rst:638
msgid ""
"Once the task list has been constructed, Fabric will start executing them as "
"outlined in :ref:`execution-strategy`, until all tasks have been run on the "
"entirety of their host lists. However, Fabric defaults to a \"fail-fast\" "
"behavior pattern: if anything goes wrong, such as a remote program returning "
"a nonzero return value or your fabfile's Python code encountering an "
"exception, execution will halt immediately."
msgstr ""
"タスクリストが構築されると、Fabricは :ref:`execution-strategy` で説明したよう"
"にこのタスクの実行を開始し、そのホストリスト全体にすべてのタスクが実行されま"
"す。とは言え、Fabricはデフォルトでは \"fail-fast\" の挙動パターンになってい"
"て、もし何かが失敗した場合、例えばリモートプログラムがノンゼロ返り値を返した"
"り、自分のfabfileのPythonコードが例外に遭遇したりした場合、すぐに停止します。"

#: ../../usage/execution.rst:645
msgid ""
"This is typically the desired behavior, but there are many exceptions to the "
"rule, so Fabric provides ``env.warn_only``, a Boolean setting. It defaults "
"to ``False``, meaning an error condition will result in the program aborting "
"immediately. However, if ``env.warn_only`` is set to ``True`` at the time of "
"failure -- with, say, the `~fabric.context_managers.settings` context "
"manager -- Fabric will emit a warning message but continue executing."
msgstr ""
"これは通常は望ましい挙動ですが、このルールにはたくさんの例外があり、そのた"
"め、Fabricはブール設定の ``env.warn_only`` を提供しています。これはデフォルト"
"では ``False`` になっていて、エラー状態はただちにそのプログラムの停止を意味し"
"ます。しかし、もし失敗時に --  `~fabric.context_managers.settings` コンテキス"
"トマネージャーなどで -- ``env.warn_only`` が ``True`` に設定されていると、"
"Fabricは警告メッセージを発しますがプログラムの実行は継続します。"

#: ../../usage/execution.rst:656
msgid "Connections"
msgstr "接続"

#: ../../usage/execution.rst:658
msgid ""
"``fab`` itself doesn't actually make any connections to remote hosts. "
"Instead, it simply ensures that for each distinct run of a task on one of "
"its hosts, the env var ``env.host_string`` is set to the right value. Users "
"wanting to leverage Fabric as a library may do so manually to achieve "
"similar effects (though as of Fabric 1.3, using `~fabric.tasks.execute` is "
"preferred and more powerful.)"
msgstr ""
"実は ``fab`` 自身ではリモートホストへの接続は行っていません。その代わり、それ"
"ぞれのホストごとに対して一つのタスクをそれぞれ個別に実行するようにすること"
"と、env変数 ``env.host_string`` に正しい値がセットされていることを単純に保証"
"しています。Fabricをライブラリとして活用したいユーザーは、手動で行うことによ"
"り同じような動作を達成することができます(とは言え、Fabric 1.3では `~fabric."
"tasks.execute` の利用をのほうが好ましく、より強力です)。"

#: ../../usage/execution.rst:665
msgid ""
"``env.host_string`` is (as the name implies) the \"current\" host string, "
"and is what Fabric uses to determine what connections to make (or re-use) "
"when network-aware functions are run. Operations like `~fabric.operations."
"run` or `~fabric.operations.put` use ``env.host_string`` as a lookup key in "
"a shared dictionary which maps host strings to SSH connection objects."
msgstr ""
"``env.host_string`` は、(その名称がほのめかしているように) \"カレントの\" ホ"
"スト文字列で、ネットワークを利用する関数が実行されるときに、どの接続を行うか"
"(もしくは再利用するか)をFabricが決定するために利用されます。 `~fabric."
"operations.run` や `~fabric.operations.put` のようなオペレーションは、ホスト"
"文字列をSSH接続オブジェクトにマップしている共有辞書内の参照キーとして ``env."
"host_string`` を利用します。"

#: ../../usage/execution.rst:673
msgid ""
"The connections dictionary (currently located at ``fabric.state."
"connections``) acts as a cache, opting to return previously created "
"connections if possible in order to save some overhead, and creating new "
"ones otherwise."
msgstr ""
"この接続用の辞書(今のところ ``fabric.state.connections`` にあります)はキャッ"
"シュとして振る舞い、オーバーヘッドを減らすために可能なら前回作成された接続を"
"返そうとし、そうした接続がなければ新たに作成します。"

#: ../../usage/execution.rst:679
msgid "Lazy connections"
msgstr "レイジーな接続"

#: ../../usage/execution.rst:681
msgid ""
"Because connections are driven by the individual operations, Fabric will not "
"actually make connections until they're necessary. Take for example this "
"task which does some local housekeeping prior to interacting with the remote "
"server::"
msgstr ""
"接続は各オペレーションによって駆動されるので、Fabricは実際に必要になるまで接"
"続を行いません。以下の例を見てください。このタスクはリモートサーバとのやりと"
"りの前にローカルでハウスキーピング処理を行います::"

#: ../../usage/execution.rst:696
msgid "What happens, connection-wise, is as follows:"
msgstr ""
"接続という観点からどのようなことが起こっているのか順に見て行きましょう:"

#: ../../usage/execution.rst:698
msgid ""
"The two `~fabric.operations.local` calls will run without making any network "
"connections whatsoever;"
msgstr ""
"2つの `~fabric.operations.local` 呼び出しがどんなものであれ接続をまったく行わ"
"ないで実行されます"

#: ../../usage/execution.rst:700
msgid ""
"`~fabric.operations.put` asks the connection cache for a connection to "
"``host1``;"
msgstr ""
"`~fabric.operations.put` が ``host1`` へ接続するための接続キャッシュを要求し"
"ます"

#: ../../usage/execution.rst:702
msgid ""
"The connection cache fails to find an existing connection for that host "
"string, and so creates a new SSH connection, returning it to `~fabric."
"operations.put`;"
msgstr ""
"接続キャッシュは該当のホスト文字列用の既存の接続を見つけられなかったので、新"
"しいSSH接続を作成し、その接続を `~fabric.operations.put` に返します"

#: ../../usage/execution.rst:705
msgid "`~fabric.operations.put` uploads the file through that connection;"
msgstr ""
"`~fabric.operations.put` がこの接続を通じてファイルをアップロードします"

#: ../../usage/execution.rst:706
msgid ""
"Finally, the `~fabric.operations.run` call asks the cache for a connection "
"to that same host string, and is given the existing, cached connection for "
"its own use."
msgstr ""
"最後に、 `~fabric.operations.run` 呼び出しが同じホスト文字列への接続のための"
"キャッシュを要求し、既存のキャッシュされた接続を自身の利用のために与えます"

#: ../../usage/execution.rst:710
msgid ""
"Extrapolating from this, you can also see that tasks which don't use any "
"network-borne operations will never actually initiate any connections "
"(though they will still be run once for each host in their host list, if "
"any.)"
msgstr ""
"以上を基に推察すると、ネットワーク関連の操作を伴わないタスクは実際にどのよう"
"な接続も始めないことがお分かりになるでしょう(ただし、もしあればですが、ホスト"
"リスト内の各ホストに一度実行されます)。"

#: ../../usage/execution.rst:715
msgid "Closing connections"
msgstr "接続の解除"

#: ../../usage/execution.rst:717
msgid ""
"Fabric's connection cache never closes connections itself -- it leaves this "
"up to whatever is using it. The :doc:`fab <fab>` tool does this bookkeeping "
"for you: it iterates over all open connections and closes them just before "
"it exits (regardless of whether the tasks failed or not.)"
msgstr ""
"Fabricの接続キャッシュは接続自身を閉じることはありません。どのように使われて"
"いてもそのままにしておきます。 :doc:`fab <fab>` ツールがその状態を保持し、す"
"べての開いている接続に対して繰り返し処理を行い、プログラムから抜け出る直前に"
"(タスクの成功、不成功に関わらず)それらの接続を閉じます。"

#: ../../usage/execution.rst:722
msgid ""
"Library users will need to ensure they explicitly close all open connections "
"before their program exits. This can be accomplished by calling `~fabric."
"network.disconnect_all` at the end of your script."
msgstr ""
"ライブラリのユーザーは、自分のプログラムから抜け出る前にすべての開いている接"
"続を確実に閉じるようにする必要が有ります。これは、自分のスクリプトの最後で "
"`~fabric.network.disconnect_all` を呼び出すことによって実施可能です。"

#: ../../usage/execution.rst:727
msgid ""
"`~fabric.network.disconnect_all` may be moved to a more public location in "
"the future; we're still working on making the library aspects of Fabric more "
"solidified and organized."
msgstr ""
"`~fabric.network.disconnect_all` は将来的にはよりパブリックな場所に移動される"
"かもしれません。わたしたちは、Fabricのライブラリとしての側面をより堅固に、よ"
"り整理されたものへしようと作業をしています。"

#: ../../usage/execution.rst:732
msgid "Multiple connection attempts and skipping bad hosts"
msgstr "複数回接続の試みとうまくいかないホストのスキップ"

#: ../../usage/execution.rst:734
msgid ""
"As of Fabric 1.4, multiple attempts may be made to connect to remote servers "
"before aborting with an error: Fabric will try connecting :ref:`env."
"connection_attempts <connection-attempts>` times before giving up, with a "
"timeout of :ref:`env.timeout <timeout>` seconds each time. (These currently "
"default to 1 try and 10 seconds, to match previous behavior, but they may be "
"safely changed to whatever you need.)"
msgstr ""
"Fabric 1.4では、エラーを伴った中止の前に、リモートサーバーへの接続が複数回試"
"行されるかもしれません。Fabricはあきらめる前に :ref:`env.connection_attempts "
"<connection-attempts>` での回数分、毎回 :ref:`env.timeout <timeout>` で指定さ"
"れた秒数のタイムアウトまで接続をトライします(これらの値は、現行では以前の挙動"
"に合わせるためデフォルトで1回と10秒になっていますが、必要に応じて安全に変更か"
"のうです)。"

#: ../../usage/execution.rst:741
msgid ""
"Furthermore, even total failure to connect to a server is no longer an "
"absolute hard stop: set :ref:`env.skip_bad_hosts <skip-bad-hosts>` to "
"``True`` and in most situations (typically initial connections) Fabric will "
"simply warn and continue, instead of aborting."
msgstr ""
"さらに、サーバへの接続の完全な失敗が完全にハード的な停止ではない場合でも "
"set :ref:`env.skip_bad_hosts <skip-bad-hosts>` を ``True`` にすれば大抵の場合"
"(通常は初期接続)でFabricは中止をする代わりに単に警告を発し、タスクの実行を続"
"けます。"

#: ../../usage/execution.rst:751
msgid "Password management"
msgstr "パスワード管理"

#: ../../usage/execution.rst:753
msgid ""
"Fabric maintains an in-memory, two-tier password cache to help remember your "
"login and sudo passwords in certain situations; this helps avoid tedious re-"
"entry when multiple systems share the same password [#]_, or if a remote "
"system's ``sudo`` configuration doesn't do its own caching."
msgstr ""
"Fabricはメモリー上に2層のパスワードキャッシュを保持し、特定の状況でのログイン"
"とsudoのパスワードを記憶します。これにより、複数システムで同じパスワードを共"
"有しているとき [#]_ やリモートシステムの ``sudo`` 設定が自身のパスワードを"
"キャッシュしない時に退屈な再入力を避けるのに役立ちます。"

#: ../../usage/execution.rst:758
msgid ""
"The first layer is a simple default or fallback password cache, :ref:`env."
"password <password>` (which may also be set at the command line via :option:"
"`--password <-p>` or :option:`--initial-password-prompt <-I>`). This env var "
"stores a single password which (if non-empty) will be tried in the event "
"that the host-specific cache (see below) has no entry for the current :ref:"
"`host string <host_string>`."
msgstr ""
"最初の層は単純なデフォルトもしくはフォールバックのパスワードのキャッシュ、 :"
"ref:`env.password <password>` です(これは :option:`--password <-p>` もしく"
"は :option:`--initial-password-prompt <-I>` 経由のコマンドラインでも設定可能"
"です)。このenv変数は(空でない場合に)特定のホストのキャッシュ(下を参照)がカレ"
"ントの :ref:`ホスト文字列 <host_string>` 用のエントリを持っていない時に試され"
"る一つのパスワードを保持します。"

#: ../../usage/execution.rst:765
msgid ""
":ref:`env.passwords <passwords>` (plural!) serves as a per-user/per-host "
"cache, storing the most recently entered password for every unique user/host/"
"port combination.  Due to this cache, connections to multiple different "
"users and/or hosts in the same session will only require a single password "
"entry for each. (Previous versions of Fabric used only the single, default "
"password cache and thus required password re-entry every time the previously "
"entered password became invalid.)"
msgstr ""
":ref:`env.passwords <passwords>` (複数形!) はユーザーごと/ホストごとのキャッ"
"シュとして利用され、ユーザー/ホスト/ポートの各組み合わせごとにもっとも最近入"
"力されたパスワードを保持します。このキャッシュのおかげで同一セッションでの複"
"数の異なるユーザーおよび/またはホストへの接続で、それぞれ一度のパスワード入力"
"だけで済ますことができます。(Fabricの以前のバージョンでは単一のデフォルトパス"
"ワードのキャッシュのみしか利用できなかったため、その前に入力されたパスワード"
"は毎回無効になり、パスワードの再入力が必要になっていました)"

#: ../../usage/execution.rst:773
msgid ""
"Depending on your configuration and the number of hosts your session will "
"connect to, you may find setting either or both of these env vars to be "
"useful. However, Fabric will automatically fill them in as necessary without "
"any additional configuration."
msgstr ""
"設定やセッションが接続するホストの数にもよりますが、このenv変数のどちらかもし"
"くは両方を設定すると便利でしょう。とは言え、Fabricは必要に応じて追加の設定な"
"しでも自動的にこれらを入力します。"

#: ../../usage/execution.rst:778
msgid ""
"Specifically, each time a password prompt is presented to the user, the "
"value entered is used to update both the single default password cache, and "
"the cache value for the current value of ``env.host_string``."
msgstr ""
"特に、ユーザーにパスワードプロンプトが表示されるたびに、入力された値は単一の"
"デフォルトパスワードキャッシュと ``env.host_string`` のカレントの値のための"
"キャッシュの値の両方のアップデートに使われます。"

#: ../../usage/execution.rst:782
msgid ""
"We highly recommend the use of SSH `key-based access <http://en.wikipedia."
"org/wiki/Public_key>`_ instead of relying on homogeneous password setups, as "
"it's significantly more secure."
msgstr ""
"同一のパスワード設定に頼るよりもSSHの `鍵ベースのアクセス <http://ja."
"wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%8D%B5%E6%9A%97%E5%8F%B7>`_ の利用を"
"強くおすすめします。こちらのほうがかなり安全です。"

#: ../../usage/execution.rst:790
msgid "Leveraging native SSH config files"
msgstr "ネイティブのSSH configファイルの活用"

#: ../../usage/execution.rst:792
msgid ""
"Command-line SSH clients (such as the one provided by `OpenSSH <http://"
"openssh.org>`_) make use of a specific configuration format typically known "
"as ``ssh_config``, and will read from a file in the platform-specific "
"location ``$HOME/.ssh/config`` (or an arbitrary path given to :option:`--ssh-"
"config-path`/:ref:`env.ssh_config_path <ssh-config-path>`.) This file allows "
"specification of various SSH options such as default or per-host usernames, "
"hostname aliases, and toggling other settings (such as whether to use :ref:"
"`agent forwarding <forward-agent>`.)"
msgstr ""
"コマンドラインのSSHクライアント( `OpenSSH <http://openssh.org>`_ によって提供"
"されているものなど)は、通常は ``ssh_config`` として知られる特定の設定フォー"
"マットを利用し、プラットフォーム特有の場所の ``$HOME/.ssh/config`` (もしく"
"は :option:`--ssh-config-path`/:ref:`env.ssh_config_path <ssh-config-path>` "
"に与えられる任意のパス)にあるファイルからそれを読み込みます。このファイルはデ"
"フォルトもしくはホストごとのユーザ名、ホスト名のエイリアス、その他設定の切り"
"替え( :ref:`エージェントフォワーディング <forward-agent>` を利用するか否かな"
"ど)など、さまざまなSSHオプションの設定を可能にします。"

#: ../../usage/execution.rst:801
msgid ""
"Fabric's SSH implementation allows loading a subset of these options from "
"one's actual SSH config file, should it exist. This behavior is not enabled "
"by default (in order to be backwards compatible) but may be turned on by "
"setting :ref:`env.use_ssh_config <use-ssh-config>` to ``True`` at the top of "
"your fabfile."
msgstr ""
"FabricのSSH実装では、実際にSSH configファイルがあればそこからこれらのオプショ"
"ンのサブセットを読み込むことが可能です。この挙動は後方互換性のためにデフォル"
"トでは有効になっていませんが、お使いのfabfileの一番上で :ref:`env."
"use_ssh_config <use-ssh-config>` を ``True`` にすることによって有効にすること"
"ができます。"

#: ../../usage/execution.rst:807
msgid ""
"If enabled, the following SSH config directives will be loaded and honored "
"by Fabric:"
msgstr ""
"これを有効にすると、次のSSH config指示が読み込まれ、Fabricによって履行されま"
"す:"

#: ../../usage/execution.rst:809
msgid ""
"``User`` and ``Port`` will be used to fill in the appropriate connection "
"parameters when not otherwise specified, in the following fashion:"
msgstr ""
"``User`` と ``Port`` は、次の方法で他に指定されない限り、適切な接続パラメータ"
"に利用されます:"

#: ../../usage/execution.rst:812
msgid ""
"Globally specified ``User``/``Port`` will be used in place of the current "
"defaults (local username and 22, respectively) if the appropriate env vars "
"are not set."
msgstr ""
"グローバルに指定された ``User``/``Port`` は、該当のenv変数がセットされていな"
"ければ、カレントの初期値(それぞれローカルのユーザー名と22)の代わりに利用され"
"ます。"

#: ../../usage/execution.rst:815
msgid ""
"However, if :ref:`env.user <user>`/:ref:`env.port <port>` *are* set, they "
"override global ``User``/``Port`` values."
msgstr ""
"しかし、 :ref:`env.user <user>`/:ref:`env.port <port>` が *セットされていれば"
"* 、グローバルの ``User``/``Port`` の値をオーバーライドします。"

#: ../../usage/execution.rst:817
msgid ""
"User/port values in the host string itself (e.g. ``hostname:222``) will "
"override everything, including any ``ssh_config`` values."
msgstr ""
"ホスト文字列自身の User/port の値(例えば``hostname:222``)は ``ssh_config`` の"
"値を含むすべてをオーバーライドします。"

#: ../../usage/execution.rst:819
msgid ""
"``HostName`` can be used to replace the given hostname, just like with "
"regular ``ssh``. So a ``Host foo`` entry specifying ``HostName example.com`` "
"will allow you to give Fabric the hostname ``'foo'`` and have that expanded "
"into ``'example.com'`` at connection time."
msgstr ""
"通常の ``ssh`` と同じように ``HostName`` は与えられたホスト名で置き換えられま"
"す。 ``HostName example.com`` を指定している ``Host foo`` のエントリーは、"
"Fabricにホスト名 ``'foo'`` を与えることができ、接続時に ``'example.com'`` に"
"展開されます。"

#: ../../usage/execution.rst:823
msgid ""
"``IdentityFile`` will extend (not replace) :ref:`env.key_filename <key-"
"filename>`."
msgstr ""
"``IdentityFile`` は :ref:`env.key_filename <key-filename>` を(置き換えるので"
"はなく)拡張します。"

#: ../../usage/execution.rst:825
msgid ""
"``ForwardAgent`` will augment :ref:`env.forward_agent <forward-agent>` in an "
"\"OR\" manner: if either is set to a positive value, agent forwarding will "
"be enabled."
msgstr ""
"``ForwardAgent`` は \"OR(論理和)\" 方式で :ref:`env.forward_agent <forward-"
"agent>` を補完します。どちらかが真の値にセットされていれば、エージェントフォ"
"ワーディングは有効になります。"

#: ../../usage/execution.rst:828
msgid ""
"``ProxyCommand`` will trigger use of a proxy command for host connections, "
"just as with regular ``ssh``."
msgstr ""
"``ProxyCommand`` は通常の ``ssh`` と同じようにホスト接続でのプロキシコマンド"
"を動作させます。"

#: ../../usage/execution.rst:832
msgid ""
"If all you want to do is bounce SSH traffic off a gateway, you may find :ref:"
"`env.gateway <gateway>` to be a more efficient connection method (which will "
"also honor more Fabric-level settings) than the typical ``ssh gatewayhost nc "
"%h %p`` method of using ``ProxyCommand`` as a gateway."
msgstr ""
"もしSSHのトラフィックをゲートウェイに送るだけなら、ゲートウェイとして "
"``ProxyCommand`` を使う通常の ``ssh gatewayhost nc %h %p`` 方式よりも :ref:"
"`env.gateway <gateway>` の方がより効率的な接続方法です。"

#: ../../usage/execution.rst:838
msgid ""
"If your SSH config file contains ``ProxyCommand`` directives *and* you have "
"set :ref:`env.gateway <gateway>` to a non-``None`` value, ``env.gateway`` "
"will take precedence and the ``ProxyCommand`` will be ignored."
msgstr ""
"もしSSH configファイルが ``ProxyCommand`` を含んでいて *なおかつ* :ref:`env."
"gateway <gateway>` が ``None`` 以外の値にセットされている場合、``env."
"gateway`` が優先され ``ProxyCommand`` は無視されます。"

#: ../../usage/execution.rst:842
msgid ""
"If one has a pre-created SSH config file, rationale states it will be easier "
"for you to modify ``env.gateway`` (e.g. via `~fabric.context_managers."
"settings`) than to work around your conf file's contents entirely."
msgstr ""
"もしすでにSSH configファイルが作成されていれば、confファイルの内容全体で対処"
"するよりも ``env.gateway`` (例えば `~fabric.context_managers.settings` 経由"
"で)を修正するほうが容易でしょう。"
