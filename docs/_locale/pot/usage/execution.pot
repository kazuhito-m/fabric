# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, Christian Vest Hansen and Jeffrey E. Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-02-15 23:41+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../usage/execution.rst:3
# 8e88a10e19d449829fd1076e1a64df11
msgid "Execution model"
msgstr ""

#: ../../usage/execution.rst:5
# 12ff4866dac24e7cb58f66c070970bff
msgid "If you've read the :doc:`../tutorial`, you should already be familiar with how Fabric operates in the base case (a single task on a single host.) However, in many situations you'll find yourself wanting to execute multiple tasks and/or on multiple hosts. Perhaps you want to split a big task into smaller reusable parts, or crawl a collection of servers looking for an old user to remove. Such a scenario requires specific rules for when and how tasks are executed."
msgstr ""

#: ../../usage/execution.rst:12
# 3bdf728f1c5f45cf86433e2191e77c0c
msgid "This document explores Fabric's execution model, including the main execution loop, how to define host lists, how connections are made, and so forth."
msgstr ""

#: ../../usage/execution.rst:19
# afaf60a2e907417ba1a2fb92a8a044fe
msgid "Execution strategy"
msgstr ""

#: ../../usage/execution.rst:21
# 49936723034d4032bf4e4dea2b579cfd
msgid "Fabric defaults to a single, serial execution method, though there is an alternative parallel mode available as of Fabric 1.3 (see :doc:`/usage/parallel`). This default behavior is as follows:"
msgstr ""

#: ../../usage/execution.rst:25
# a69db61d25ae4f2cb5859f4080ebf813
msgid "A list of tasks is created. Currently this list is simply the arguments given to :doc:`fab <fab>`, preserving the order given."
msgstr ""

#: ../../usage/execution.rst:27
# 938eb6ccbb7e428499345bdd394e12bb
msgid "For each task, a task-specific host list is generated from various sources (see :ref:`host-lists` below for details.)"
msgstr ""

#: ../../usage/execution.rst:29
# e23725808df14b2289f6618258db21c7
msgid "The task list is walked through in order, and each task is run once per host in its host list."
msgstr ""

#: ../../usage/execution.rst:31
# 602ff674d22c4003aabe7c6a7b1ccacd
msgid "Tasks with no hosts in their host list are considered local-only, and will always run once and only once."
msgstr ""

#: ../../usage/execution.rst:34
# bd9a0ecfdbe245c2964220a0e2c54773
msgid "Thus, given the following fabfile::"
msgstr ""

#: ../../usage/execution.rst:46
# d67102804bea4a09b2b6f319328c7650
msgid "and the following invocation::"
msgstr ""

#: ../../usage/execution.rst:50
# 579f988ad0e94267aba79170ac752eae
msgid "you will see that Fabric performs the following:"
msgstr ""

#: ../../usage/execution.rst:52
# e3da26bd2751493aa5bbf153aac99459
msgid "``taskA`` executed on ``host1``"
msgstr ""

#: ../../usage/execution.rst:53
# 84b5a93a67ee4cffa5a807efeb197397
msgid "``taskA`` executed on ``host2``"
msgstr ""

#: ../../usage/execution.rst:54
# 353973dc3e364fa3b93a372eea925663
msgid "``taskB`` executed on ``host1``"
msgstr ""

#: ../../usage/execution.rst:55
# c5fa3002b27647238ef4ab18e904e06c
msgid "``taskB`` executed on ``host2``"
msgstr ""

#: ../../usage/execution.rst:57
# f12407e40611455fa2d652df94e9cde4
msgid "While this approach is simplistic, it allows for a straightforward composition of task functions, and (unlike tools which push the multi-host functionality down to the individual function calls) enables shell script-like logic where you may introspect the output or return code of a given command and decide what to do next."
msgstr ""

#: ../../usage/execution.rst:65
# 30a9fc4b6ed741058acc5d37085b963c
msgid "Defining tasks"
msgstr ""

#: ../../usage/execution.rst:67
# e5f7327fa80e44b7a524ac09dcafbaed
msgid "For details on what constitutes a Fabric task and how to organize them, please see :doc:`/usage/tasks`."
msgstr ""

#: ../../usage/execution.rst:71
# 8a82e022a8074b178f337c1db2b53259
msgid "Defining host lists"
msgstr ""

#: ../../usage/execution.rst:73
# adf7af1b37c148dcb3d039b9d002fd85
msgid "Unless you're using Fabric as a simple build system (which is possible, but not the primary use-case) having tasks won't do you any good without the ability to specify remote hosts on which to execute them. There are a number of ways to do so, with scopes varying from global to per-task, and it's possible mix and match as needed."
msgstr ""

#: ../../usage/execution.rst:82
# 69947742ac9743e6b44e7446f4f6593c
msgid "Hosts"
msgstr ""

#: ../../usage/execution.rst:84
# 596ab7b82ad54995a4bfc043e6d0a110
msgid "Hosts, in this context, refer to what are also called \"host strings\": Python strings specifying a username, hostname and port combination, in the form of ``username@hostname:port``. User and/or port (and the associated ``@`` or ``:``) may be omitted, and will be filled by the executing user's local username, and/or port 22, respectively. Thus, ``admin@foo.com:222``, ``deploy@website`` and ``nameserver1`` could all be valid host strings."
msgstr ""

#: ../../usage/execution.rst:91
# 8814f12fd77c462eb6af7fb3996078aa
msgid "IPv6 address notation is also supported, for example ``::1``, ``[::1]:1222``, ``user@2001:db8::1`` or ``user@[2001:db8::1]:1222``. Square brackets are necessary only to separate the address from the port number. If no port number is used, the brackets are optional. Also if host string is specified via command-line argument, it may be necessary to escape brackets in some shells."
msgstr ""

#: ../../usage/execution.rst:99
# b4979c72c3d548e0aa237f0a8827c73d
msgid "The user/hostname split occurs at the last ``@`` found, so e.g. email address usernames are valid and will be parsed correctly."
msgstr ""

#: ../../usage/execution.rst:102
# 726704edb1e74c2dbe8e6f92d11c3675
msgid "During execution, Fabric normalizes the host strings given and then stores each part (username/hostname/port) in the environment dictionary, for both its use and for tasks to reference if the need arises. See :doc:`env` for details."
msgstr ""

#: ../../usage/execution.rst:109
# 0103047df6bd4fb890361de4d1a9b033
msgid "Roles"
msgstr ""

#: ../../usage/execution.rst:111
# f75da8adbb3b4acfbafcd3027ab96873
msgid "Host strings map to single hosts, but sometimes it's useful to arrange hosts in groups. Perhaps you have a number of Web servers behind a load balancer and want to update all of them, or want to run a task on \"all client servers\". Roles provide a way of defining strings which correspond to lists of host strings, and can then be specified instead of writing out the entire list every time."
msgstr ""

#: ../../usage/execution.rst:118
# bfc500b1e3a34e5981535ac0bcd3c03a
msgid "This mapping is defined as a dictionary, ``env.roledefs``, which must be modified by a fabfile in order to be used. A simple example::"
msgstr ""

#: ../../usage/execution.rst:125
# bda329d2930646bc84d1b98b2b872594
msgid "Since ``env.roledefs`` is naturally empty by default, you may also opt to re-assign to it without fear of losing any information (provided you aren't loading other fabfiles which also modify it, of course)::"
msgstr ""

#: ../../usage/execution.rst:136
# ee0348af613c467392be490d9452e563
msgid "In addition to list/iterable object types, the values in ``env.roledefs`` may be callables, and will thus be called when looked up when tasks are run instead of at module load time. (For example, you could connect to remote servers to obtain role definitions, and not worry about causing delays at fabfile load time when calling e.g. ``fab --list``.)"
msgstr ""

#: ../../usage/execution.rst:142
# 1a5105f3c9504e82a8d7f637f5f07870
msgid "Use of roles is not required in any way -- it's simply a convenience in situations where you have common groupings of servers."
msgstr ""

#: ../../usage/execution.rst:145
# 7efde23c07a04bc1a4e63bc044455586
msgid "Added ability to use callables as ``roledefs`` values."
msgstr ""

#: ../../usage/execution.rst:151
# 628732803e1a4dcf9425b12043f32ff4
msgid "How host lists are constructed"
msgstr ""

#: ../../usage/execution.rst:153
# 04d3c27ca2384a769858d0d065d62662
msgid "There are a number of ways to specify host lists, either globally or per-task, and generally these methods override one another instead of merging together (though this may change in future releases.) Each such method is typically split into two parts, one for hosts and one for roles."
msgstr ""

#: ../../usage/execution.rst:159
# e9eab3e1f1fc4fce96291c6297c553e6
msgid "Globally, via ``env``"
msgstr ""

#: ../../usage/execution.rst:161
# 75f0d07e343a474b800ae883ec33df22
msgid "The most common method of setting hosts or roles is by modifying two key-value pairs in the environment dictionary, :doc:`env <env>`: ``hosts`` and ``roles``. The value of these variables is checked at runtime, while constructing each tasks's host list."
msgstr ""

#: ../../usage/execution.rst:166
# 4acc8b07bf06480aa0de44cfb03e1838
msgid "Thus, they may be set at module level, which will take effect when the fabfile is imported::"
msgstr ""

#: ../../usage/execution.rst:176
# 2d41afa8e8b94bb79e6accb7197c0d09
msgid "Such a fabfile, run simply as ``fab mytask``, will run ``mytask`` on ``host1`` followed by ``host2``."
msgstr ""

#: ../../usage/execution.rst:179
# fd959063b6594bd8a256f2c94a58e5ea
msgid "Since the env vars are checked for *each* task, this means that if you have the need, you can actually modify ``env`` in one task and it will affect all following tasks::"
msgstr ""

#: ../../usage/execution.rst:191
# fe79e8fff95e4e4d8b403b21039ac9c4
msgid "When run as ``fab set_hosts mytask``, ``set_hosts`` is a \"local\" task -- its own host list is empty -- but ``mytask`` will again run on the two hosts given."
msgstr ""

#: ../../usage/execution.rst:196
# 1d0ddbe78a0d49e1862e01b03c8bf0e3
msgid "This technique used to be a common way of creating fake \"roles\", but is less necessary now that roles are fully implemented. It may still be useful in some situations, however."
msgstr ""

#: ../../usage/execution.rst:200
# 46bcafa759a245dd87eb877d68c6186a
msgid "Alongside ``env.hosts`` is ``env.roles`` (not to be confused with ``env.roledefs``!) which, if given, will be taken as a list of role names to look up in ``env.roledefs``."
msgstr ""

#: ../../usage/execution.rst:205
# be77288d72ba4f76a0f7c0f2c5608e97
msgid "Globally, via the command line"
msgstr ""

#: ../../usage/execution.rst:207
# fae1d6d3ed874fde9c03812c2943f728
msgid "In addition to modifying ``env.hosts``, ``env.roles``, and ``env.exclude_hosts`` at the module level, you may define them by passing comma-separated string arguments to the command-line switches :option:`--hosts/-H <-H>` and :option:`--roles/-R <-R>`, e.g.::"
msgstr ""

#: ../../usage/execution.rst:214
# 6289a03fd90e41788b46cf1da3261f42
msgid "Such an invocation is directly equivalent to ``env.hosts = ['host1', 'host2']`` -- the argument parser knows to look for these arguments and will modify ``env`` at parse time."
msgstr ""

#: ../../usage/execution.rst:220
# ebef50c7f2bc4195bfe54a540136ed80
msgid "It's possible, and in fact common, to use these switches to set only a single host or role. Fabric simply calls ``string.split(',')`` on the given string, so a string with no commas turns into a single-item list."
msgstr ""

#: ../../usage/execution.rst:224
# 58104a19bb86445b9f5fbaf2abe65ae4
msgid "It is important to know that these command-line switches are interpreted **before** your fabfile is loaded: any reassignment to ``env.hosts`` or ``env.roles`` in your fabfile will overwrite them."
msgstr ""

#: ../../usage/execution.rst:228
# e81bfc12d3114fe5866c5d9f5f706cbf
msgid "If you wish to nondestructively merge the command-line hosts with your fabfile-defined ones, make sure your fabfile uses ``env.hosts.extend()`` instead::"
msgstr ""

#: ../../usage/execution.rst:239
# 2280bf2a51184fa7aaddfa53ad2078cd
msgid "When this fabfile is run as ``fab -H host1,host2 mytask``, ``env.hosts`` will then contain ``['host1', 'host2', 'host3', 'host4']`` at the time that ``mytask`` is executed."
msgstr ""

#: ../../usage/execution.rst:245
# f6fb24ded37c49c19a0f6578fc8bb7bb
msgid "``env.hosts`` is simply a Python list object -- so you may use ``env.hosts.append()`` or any other such method you wish."
msgstr ""

#: ../../usage/execution.rst:251
# 2519199c206c44ce980c3f0178661b60
msgid "Per-task, via the command line"
msgstr ""

#: ../../usage/execution.rst:253
# 4181e797d6644cbc94bd4c849f531c1d
msgid "Globally setting host lists only works if you want all your tasks to run on the same host list all the time. This isn't always true, so Fabric provides a few ways to be more granular and specify host lists which apply to a single task only. The first of these uses task arguments."
msgstr ""

#: ../../usage/execution.rst:258
# d661883a856b4b4ca7049620b329c198
msgid "As outlined in :doc:`fab`, it's possible to specify per-task arguments via a special command-line syntax. In addition to naming actual arguments to your task function, this may be used to set the ``host``, ``hosts``, ``role`` or ``roles`` \"arguments\", which are interpreted by Fabric when building host lists (and removed from the arguments passed to the task itself.)"
msgstr ""

#: ../../usage/execution.rst:266
# d0808b7e3e9b4cdcb6576964596b5c77
msgid "Since commas are already used to separate task arguments from one another, semicolons must be used in the ``hosts`` or ``roles`` arguments to delineate individual host strings or role names. Furthermore, the argument must be quoted to prevent your shell from interpreting the semicolons."
msgstr ""

#: ../../usage/execution.rst:271
# 7a0106e74f6f423b8f1ca1b8fedc458f
msgid "Take the below fabfile, which is the same one we've been using, but which doesn't define any host info at all::"
msgstr ""

#: ../../usage/execution.rst:279
# e3f3d46079874892bdc4c186d20a9717
msgid "To specify per-task hosts for ``mytask``, execute it like so::"
msgstr ""

#: ../../usage/execution.rst:283
# ae39ca6415ff4c6e8e0c0fb760c4c9b9
msgid "This will override any other host list and ensure ``mytask`` always runs on just those two hosts."
msgstr ""

#: ../../usage/execution.rst:287
# f686e00e97d14bd185ce13532648a9d5
msgid "Per-task, via decorators"
msgstr ""

#: ../../usage/execution.rst:289
# 5345cda171794f8a92f55df4a93563c9
msgid "If a given task should always run on a predetermined host list, you may wish to specify this in your fabfile itself. This can be done by decorating a task function with the `~fabric.decorators.hosts` or `~fabric.decorators.roles` decorators. These decorators take a variable argument list, like so::"
msgstr ""

#: ../../usage/execution.rst:300
# 734f18ffe6f147e4a62cdfc5e82b59a0
msgid "They will also take an single iterable argument, e.g.::"
msgstr ""

#: ../../usage/execution.rst:307
# f5f7a2598f684204a2cc86d5ebd92eb8
msgid "When used, these decorators override any checks of ``env`` for that particular task's host list (though ``env`` is not modified in any way -- it is simply ignored.) Thus, even if the above fabfile had defined ``env.hosts`` or the call to :doc:`fab <fab>` uses :option:`--hosts/-H <-H>`, ``mytask`` would still run on a host list of ``['host1', 'host2']``."
msgstr ""

#: ../../usage/execution.rst:313
# 0985e673cc8a4f6b94b9064b25994460
msgid "However, decorator host lists do **not** override per-task command-line arguments, as given in the previous section."
msgstr ""

#: ../../usage/execution.rst:317
# 652f59694ca64536b2fb266b3a001cca
msgid "Order of precedence"
msgstr ""

#: ../../usage/execution.rst:319
# 3d6a9958c77747d2a81382ac4af31aec
msgid "We've been pointing out which methods of setting host lists trump the others, as we've gone along. However, to make things clearer, here's a quick breakdown:"
msgstr ""

#: ../../usage/execution.rst:322
# cb8dfbef2a344f189e03e48dbf5e8d08
msgid "Per-task, command-line host lists (``fab mytask:host=host1``) override absolutely everything else."
msgstr ""

#: ../../usage/execution.rst:324
# 2068d2c5ff55428492fbc0b36cd1b095
msgid "Per-task, decorator-specified host lists (``@hosts('host1')``) override the ``env`` variables."
msgstr ""

#: ../../usage/execution.rst:326
# f22ebc8eda24478a9b2b460d93858dda
msgid "Globally specified host lists set in the fabfile (``env.hosts = ['host1']``) *can* override such lists set on the command-line, but only if you're not careful (or want them to.)"
msgstr ""

#: ../../usage/execution.rst:329
# a46ccd08943145c9b3126ec5659a4981
msgid "Globally specified host lists set on the command-line (``--hosts=host1``) will initialize the ``env`` variables, but that's it."
msgstr ""

#: ../../usage/execution.rst:332
# 4e9510565ebf4436bcb44f8f9e3deb66
msgid "This logic may change slightly in the future to be more consistent (e.g. having :option:`--hosts <-H>` somehow take precedence over ``env.hosts`` in the same way that command-line per-task lists trump in-code ones) but only in a backwards-incompatible release."
msgstr ""

#: ../../usage/execution.rst:340
# 3ef71e97b05d42e2b3c9265d2c0abf63
msgid "Combining host lists"
msgstr ""

#: ../../usage/execution.rst:342
# 4ddb623e63154002bab508a5d05557fc
msgid "There is no \"unionizing\" of hosts between the various sources mentioned in :ref:`host-lists`. If ``env.hosts`` is set to ``['host1', 'host2', 'host3']``, and a per-function (e.g.  via `~fabric.decorators.hosts`) host list is set to just ``['host2', 'host3']``, that function will **not** execute on ``host1``, because the per-task decorator host list takes precedence."
msgstr ""

#: ../../usage/execution.rst:348
# 2f76149c79e74566bb118d3ce7681ccd
msgid "However, for each given source, if both roles **and** hosts are specified, they will be merged together into a single host list. Take, for example, this fabfile where both of the decorators are used::"
msgstr ""

#: ../../usage/execution.rst:361
# 804896eab5644000858f3249d142740c
msgid "Assuming no command-line hosts or roles are given when ``mytask`` is executed, this fabfile will call ``mytask`` on a host list of ``['a', 'b', 'c']`` -- the union of ``role1`` and the contents of the `~fabric.decorators.hosts` call."
msgstr ""

#: ../../usage/execution.rst:369
# 6411baa879d54ce3bc4d3e92c68b98b4
msgid "Host list deduplication"
msgstr ""

#: ../../usage/execution.rst:371
# 8f8ec3b322cf43069f625f90544a06a9
msgid "By default, to support :ref:`combining-host-lists`, Fabric deduplicates the final host list so any given host string is only present once. However, this prevents explicit/intentional running of a task multiple times on the same target host, which is sometimes useful."
msgstr ""

#: ../../usage/execution.rst:376
# b8d63e5ad1a1409a9c5e559be102e5af
msgid "To turn off deduplication, set :ref:`env.dedupe_hosts <dedupe_hosts>` to ``False``."
msgstr ""

#: ../../usage/execution.rst:383
# bcb59acd1c584fc4862dcd8b24bd724c
msgid "Excluding specific hosts"
msgstr ""

#: ../../usage/execution.rst:385
# 89eb40acc1a246c8a9cc3efa4ee5ed4f
msgid "At times, it is useful to exclude one or more specific hosts, e.g. to override a few bad or otherwise undesirable hosts which are pulled in from a role or an autogenerated host list."
msgstr ""

#: ../../usage/execution.rst:390
# a52d29fa8d9a4d6e9d56669be2ccaca3
msgid "As of Fabric 1.4, you may wish to use :ref:`skip-bad-hosts` instead, which automatically skips over any unreachable hosts."
msgstr ""

#: ../../usage/execution.rst:393
# 77afa90310d54445a3e8517fc94da7d7
msgid "Host exclusion may be accomplished globally with :option:`--exclude-hosts/-x <-x>`::"
msgstr ""

#: ../../usage/execution.rst:398
# ee8b44099ca1426fa8d086f8ec4aa930
msgid "If ``myrole`` was defined as ``['host1', 'host2', ..., 'host15']``, the above invocation would run with an effective host list of ``['host1', 'host3', 'host4', 'host6', ..., 'host15']``."
msgstr ""

#: ../../usage/execution.rst:403
# 64016f8280984fe9992551db3918ae9c
msgid "Using this option does not modify ``env.hosts`` -- it only causes the main execution loop to skip the requested hosts."
msgstr ""

#: ../../usage/execution.rst:406
# d29c2a10cf6548ebbd4bc7390a543c47
msgid "Exclusions may be specified per-task by using an extra ``exclude_hosts`` kwarg, which is implemented similarly to the abovementioned ``hosts`` and ``roles`` per-task kwargs, in that it is stripped from the actual task invocation. This example would have the same result as the global exclude above::"
msgstr ""

#: ../../usage/execution.rst:413
# 2674207d57bb4b919154ef12c3c9cb8e
msgid "Note that the host list is semicolon-separated, just as with the ``hosts`` per-task argument."
msgstr ""

#: ../../usage/execution.rst:417
# 69ff4558240d46ccb3170edeb15435c6
msgid "Combining exclusions"
msgstr ""

#: ../../usage/execution.rst:419
# c39454b7748f4245b35a9d3098468dc5
msgid "Host exclusion lists, like host lists themselves, are not merged together across the different \"levels\" they can be declared in. For example, a global ``-x`` option will not affect a per-task host list set with a decorator or keyword argument, nor will per-task ``exclude_hosts`` keyword arguments affect a global ``-H`` list."
msgstr ""

#: ../../usage/execution.rst:425
# 31a47bb3a31744b780c0641482b53a8b
msgid "There is one minor exception to this rule, namely that CLI-level keyword arguments (``mytask:exclude_hosts=x,y``) **will** be taken into account when examining host lists set via ``@hosts`` or ``@roles``. Thus a task function decorated with ``@hosts('host1', 'host2')`` executed as ``fab taskname:exclude_hosts=host2`` will only run on ``host1``."
msgstr ""

#: ../../usage/execution.rst:431
# c25edf2b2d984dfc972885b72b5c3861
msgid "As with the host list merging, this functionality is currently limited (partly to keep the implementation simple) and may be expanded in future releases."
msgstr ""

#: ../../usage/execution.rst:438
# aff5e2ed1f7b46bda1c72be06d7d141f
msgid "Intelligently executing tasks with ``execute``"
msgstr ""

#: ../../usage/execution.rst:442
# f5babebb3ffd4f09bdb62cbbcc9800c8
msgid "Most of the information here involves \"top level\" tasks executed via :doc:`fab <fab>`, such as the first example where we called ``fab taskA taskB``. However, it's often convenient to wrap up multi-task invocations like this into their own, \"meta\" tasks."
msgstr ""

#: ../../usage/execution.rst:447
# b03c2197412a4263bfb6898fac519654
msgid "Prior to Fabric 1.3, this had to be done by hand, as outlined in :doc:`/usage/library`. Fabric's design eschews magical behavior, so simply *calling* a task function does **not** take into account decorators such as `~fabric.decorators.roles`."
msgstr ""

#: ../../usage/execution.rst:452
# b96a38d38917489da2e975c558cdcf5d
msgid "New in Fabric 1.3 is the `~fabric.tasks.execute` helper function, which takes a task object or name as its first argument. Using it is effectively the same as calling the given task from the command line: all the rules given above in :ref:`host-lists` apply. (The ``hosts`` and ``roles`` keyword arguments to `~fabric.tasks.execute` are analogous to :ref:`CLI per-task arguments <hosts-per-task-cli>`, including how they override all other host/role-setting methods.)"
msgstr ""

#: ../../usage/execution.rst:460
# e98ee1fa7a91488c9d20e2c9ad3b4c6a
msgid "As an example, here's a fabfile defining two stand-alone tasks for deploying a Web application::"
msgstr ""

#: ../../usage/execution.rst:480
# 2bed6ceb333e4c1da9f3d2178f83dbd5
msgid "In Fabric <=1.2, the only way to ensure that ``migrate`` runs on the DB servers and that ``update`` runs on the Web servers (short of manual ``env.host_string`` manipulation) was to call both as top level tasks::"
msgstr ""

#: ../../usage/execution.rst:486
# d4fdc929840945f8af0617867ae0f5c0
msgid "Fabric >=1.3 can use `~fabric.tasks.execute` to set up a meta-task. Update the ``import`` line like so::"
msgstr ""

#: ../../usage/execution.rst:491
# d4d008b25273476a8aaa763fb7bacaac
msgid "and append this to the bottom of the file::"
msgstr ""

#: ../../usage/execution.rst:497
# fabef134b29c452ba3ff6f5215d15df9
msgid "That's all there is to it; the `~fabric.decorators.roles` decorators will be honored as expected, resulting in the following execution sequence:"
msgstr ""

#: ../../usage/execution.rst:499
# 10479bd59e9e4793bed33c3b7c6d1d6e
msgid "`migrate` on `db1`"
msgstr ""

#: ../../usage/execution.rst:500
# d1c53fe1c3b84e2c99ca28b7715f9449
msgid "`migrate` on `db2`"
msgstr ""

#: ../../usage/execution.rst:501
# f9251c0ae676446dbd313a01fcba5f0c
msgid "`update` on `web1`"
msgstr ""

#: ../../usage/execution.rst:502
# 1305ecf2b7914376bb2e34be022cf673
msgid "`update` on `web2`"
msgstr ""

#: ../../usage/execution.rst:503
# 1f0d12dccbcd4def825f5aa301945c34
msgid "`update` on `web3`"
msgstr ""

#: ../../usage/execution.rst:506
# f23fd2e48205424fa9741f862d946b52
msgid "This technique works because tasks that themselves have no host list (this includes the global host list settings) only run one time. If used inside a \"regular\" task that is going to run on multiple hosts, calls to `~fabric.tasks.execute` will also run multiple times, resulting in multiplicative numbers of subtask calls -- be careful!"
msgstr ""

#: ../../usage/execution.rst:512
# d540a757d8a14b56983c9a6f50d025ab
msgid "If you would like your `execute` calls to only be called once, you may use the `~fabric.decorators.runs_once` decorator."
msgstr ""

#: ../../usage/execution.rst:515
# 13f25b30335e4576b9477aaaf6e74f5a
msgid "`~fabric.tasks.execute`, `~fabric.decorators.runs_once`"
msgstr ""

#: ../../usage/execution.rst:521
# 47b55d19fa6e4cb1a64d0e65c04f8a94
msgid "Leveraging ``execute`` to access multi-host results"
msgstr ""

#: ../../usage/execution.rst:523
# 21316484e8b64723ad6f9c338803cd83
msgid "In nontrivial Fabric runs, especially parallel ones, you may want to gather up a bunch of per-host result values at the end - e.g. to present a summary table, perform calculations, etc."
msgstr ""

#: ../../usage/execution.rst:527
# cbc557c595914fad81d74e990e6bc0e2
msgid "It's not possible to do this in Fabric's default \"naive\" mode (one where you rely on Fabric looping over host lists on your behalf), but with `.execute` it's pretty easy. Simply switch from calling the actual work-bearing task, to calling a \"meta\" task which takes control of execution with `.execute`::"
msgstr ""

#: ../../usage/execution.rst:544
# df203537e7ba45659b44074a9908d178
msgid "In the above, ``workhorse`` can do any Fabric stuff at all -- it's literally your old \"naive\" task -- except that it needs to return something useful."
msgstr ""

#: ../../usage/execution.rst:547
# dc8827a0597e4a63998b10b1391d6791
msgid "``go`` is your new entry point (to be invoked as ``fab go``, or whatnot) and its job is to take the ``results`` dictionary from the `.execute` call and do whatever you need with it. Check the API docs for details on the structure of that return value."
msgstr ""

#: ../../usage/execution.rst:556
# 02c223784b68499d9dd8f528610ba9a7
msgid "Using ``execute`` with dynamically-set host lists"
msgstr ""

#: ../../usage/execution.rst:558
# 29ecd48e47a547cd8cdbad514f1854d1
msgid "A common intermediate-to-advanced use case for Fabric is to parameterize lookup of one's target host list at runtime (when use of :ref:`execution-roles` does not suffice). ``execute`` can make this extremely simple, like so::"
msgstr ""

#: ../../usage/execution.rst:583
# 7d2feb88702f4ff78423641df7878a27
msgid "For example, if ``external_datastore`` was a simplistic \"look up hosts by tag in a database\" service, and you wanted to run a task on all hosts tagged as being related to your application stack, you might call the above like this::"
msgstr ""

#: ../../usage/execution.rst:589
# a7002380137b4ff68a94ed9b56e4a275
msgid "But wait! A data migration has gone awry on the DB servers. Let's fix up our migration code in our source repo, and deploy just the DB boxes again::"
msgstr ""

#: ../../usage/execution.rst:594
# 75a920a0443c4a8391b770cbcdd37628
msgid "This use case looks similar to Fabric's roles, but has much more potential, and is by no means limited to a single argument. Define the task however you wish, query your external data store in whatever way you need -- it's just Python."
msgstr ""

#: ../../usage/execution.rst:599
# bef5e74a62f046aca6e8d36845d1271b
msgid "The alternate approach"
msgstr ""

#: ../../usage/execution.rst:601
# 3a45eecaf5f14ec9baf75bbaa399e47c
msgid "Similar to the above, but using ``fab``'s ability to call multiple tasks in succession instead of an explicit ``execute`` call, is to mutate :ref:`env.hosts <hosts>` in a host-list lookup task and then call ``do_work`` in the same session::"
msgstr ""

#: ../../usage/execution.rst:621
# cf7cbd4a8c5b4012b2defc53b7bf9f2a
msgid "Then invoke like so::"
msgstr ""

#: ../../usage/execution.rst:625
# 35e12e5acfb04d3fa48ecb393936e86b
msgid "One benefit of this approach over the previous one is that you can replace ``do_work`` with any other \"workhorse\" task::"
msgstr ""

#: ../../usage/execution.rst:636
# 2e801af3d3a144fdb0ed0583c7b3b373
msgid "Failure handling"
msgstr ""

#: ../../usage/execution.rst:638
# 931724887f7849b085e237cb2634b480
msgid "Once the task list has been constructed, Fabric will start executing them as outlined in :ref:`execution-strategy`, until all tasks have been run on the entirety of their host lists. However, Fabric defaults to a \"fail-fast\" behavior pattern: if anything goes wrong, such as a remote program returning a nonzero return value or your fabfile's Python code encountering an exception, execution will halt immediately."
msgstr ""

#: ../../usage/execution.rst:645
# 9ba10b8251c54681bb3352791fb7f082
msgid "This is typically the desired behavior, but there are many exceptions to the rule, so Fabric provides ``env.warn_only``, a Boolean setting. It defaults to ``False``, meaning an error condition will result in the program aborting immediately. However, if ``env.warn_only`` is set to ``True`` at the time of failure -- with, say, the `~fabric.context_managers.settings` context manager -- Fabric will emit a warning message but continue executing."
msgstr ""

#: ../../usage/execution.rst:656
# f1c3af34921b4f18a6ba3ead73d4d9ec
msgid "Connections"
msgstr ""

#: ../../usage/execution.rst:658
# 20ff4247d1ff42d0b3a60b290a883c1a
msgid "``fab`` itself doesn't actually make any connections to remote hosts. Instead, it simply ensures that for each distinct run of a task on one of its hosts, the env var ``env.host_string`` is set to the right value. Users wanting to leverage Fabric as a library may do so manually to achieve similar effects (though as of Fabric 1.3, using `~fabric.tasks.execute` is preferred and more powerful.)"
msgstr ""

#: ../../usage/execution.rst:665
# 4f986079aeb84a3e858cb216ae86c05b
msgid "``env.host_string`` is (as the name implies) the \"current\" host string, and is what Fabric uses to determine what connections to make (or re-use) when network-aware functions are run. Operations like `~fabric.operations.run` or `~fabric.operations.put` use ``env.host_string`` as a lookup key in a shared dictionary which maps host strings to SSH connection objects."
msgstr ""

#: ../../usage/execution.rst:673
# 64fd7ef67bae4763b114ff1fa6428f05
msgid "The connections dictionary (currently located at ``fabric.state.connections``) acts as a cache, opting to return previously created connections if possible in order to save some overhead, and creating new ones otherwise."
msgstr ""

#: ../../usage/execution.rst:679
# f3a97119bf8741e7a1cbd3da1e001a5f
msgid "Lazy connections"
msgstr ""

#: ../../usage/execution.rst:681
# 6ec161aefbc247efb548bd8345ae516e
msgid "Because connections are driven by the individual operations, Fabric will not actually make connections until they're necessary. Take for example this task which does some local housekeeping prior to interacting with the remote server::"
msgstr ""

#: ../../usage/execution.rst:696
# 48c0cf7538244d249342b59323ac7aae
msgid "What happens, connection-wise, is as follows:"
msgstr ""

#: ../../usage/execution.rst:698
# a5a641f54b0446a988936ee884e129bc
msgid "The two `~fabric.operations.local` calls will run without making any network connections whatsoever;"
msgstr ""

#: ../../usage/execution.rst:700
# e5c917c4665742ce85408cb4e5d65f05
msgid "`~fabric.operations.put` asks the connection cache for a connection to ``host1``;"
msgstr ""

#: ../../usage/execution.rst:702
# 6cbf0b7cee0c4103a047b1f7a17c64d8
msgid "The connection cache fails to find an existing connection for that host string, and so creates a new SSH connection, returning it to `~fabric.operations.put`;"
msgstr ""

#: ../../usage/execution.rst:705
# e1fdfddabd654e3a98591689edb62494
msgid "`~fabric.operations.put` uploads the file through that connection;"
msgstr ""

#: ../../usage/execution.rst:706
# 8f0019f29ddd40c69cee34ad9d8cd0b6
msgid "Finally, the `~fabric.operations.run` call asks the cache for a connection to that same host string, and is given the existing, cached connection for its own use."
msgstr ""

#: ../../usage/execution.rst:710
# 6b7c6f1a8ba84033ae00dd0b360ccd74
msgid "Extrapolating from this, you can also see that tasks which don't use any network-borne operations will never actually initiate any connections (though they will still be run once for each host in their host list, if any.)"
msgstr ""

#: ../../usage/execution.rst:715
# 9e6b04311c43429a884d21da13b77e86
msgid "Closing connections"
msgstr ""

#: ../../usage/execution.rst:717
# f716141afd9f4afca1fca98f1210daca
msgid "Fabric's connection cache never closes connections itself -- it leaves this up to whatever is using it. The :doc:`fab <fab>` tool does this bookkeeping for you: it iterates over all open connections and closes them just before it exits (regardless of whether the tasks failed or not.)"
msgstr ""

#: ../../usage/execution.rst:722
# 0aa23a33e23546f9a3a84cea4f726ef7
msgid "Library users will need to ensure they explicitly close all open connections before their program exits. This can be accomplished by calling `~fabric.network.disconnect_all` at the end of your script."
msgstr ""

#: ../../usage/execution.rst:727
# 55110e0798a94f0da2a0731653141e85
msgid "`~fabric.network.disconnect_all` may be moved to a more public location in the future; we're still working on making the library aspects of Fabric more solidified and organized."
msgstr ""

#: ../../usage/execution.rst:732
# cc97392d7dc04a29ad1fc55565dcd537
msgid "Multiple connection attempts and skipping bad hosts"
msgstr ""

#: ../../usage/execution.rst:734
# 6fb274f1dead4f2e8e753e166499ed36
msgid "As of Fabric 1.4, multiple attempts may be made to connect to remote servers before aborting with an error: Fabric will try connecting :ref:`env.connection_attempts <connection-attempts>` times before giving up, with a timeout of :ref:`env.timeout <timeout>` seconds each time. (These currently default to 1 try and 10 seconds, to match previous behavior, but they may be safely changed to whatever you need.)"
msgstr ""

#: ../../usage/execution.rst:741
# 4c6c709ce7b64566ac2a1e55fefe562c
msgid "Furthermore, even total failure to connect to a server is no longer an absolute hard stop: set :ref:`env.skip_bad_hosts <skip-bad-hosts>` to ``True`` and in most situations (typically initial connections) Fabric will simply warn and continue, instead of aborting."
msgstr ""

#: ../../usage/execution.rst:751
# efb4b880e47a4ba0ae1d1588ed06dd92
msgid "Password management"
msgstr ""

#: ../../usage/execution.rst:753
# 3a04ae5d07a042d1b23fec27a2a6e35b
msgid "Fabric maintains an in-memory, two-tier password cache to help remember your login and sudo passwords in certain situations; this helps avoid tedious re-entry when multiple systems share the same password [#]_, or if a remote system's ``sudo`` configuration doesn't do its own caching."
msgstr ""

#: ../../usage/execution.rst:758
# 763346ada4fa4bd7bf38533129cee2c2
msgid "The first layer is a simple default or fallback password cache, :ref:`env.password <password>` (which may also be set at the command line via :option:`--password <-p>` or :option:`--initial-password-prompt <-I>`). This env var stores a single password which (if non-empty) will be tried in the event that the host-specific cache (see below) has no entry for the current :ref:`host string <host_string>`."
msgstr ""

#: ../../usage/execution.rst:765
# d3d92945da83477a80b7aac624e2fc1d
msgid ":ref:`env.passwords <passwords>` (plural!) serves as a per-user/per-host cache, storing the most recently entered password for every unique user/host/port combination.  Due to this cache, connections to multiple different users and/or hosts in the same session will only require a single password entry for each. (Previous versions of Fabric used only the single, default password cache and thus required password re-entry every time the previously entered password became invalid.)"
msgstr ""

#: ../../usage/execution.rst:773
# 475c44f5e28d47e5af7c1bab05d4e5ce
msgid "Depending on your configuration and the number of hosts your session will connect to, you may find setting either or both of these env vars to be useful. However, Fabric will automatically fill them in as necessary without any additional configuration."
msgstr ""

#: ../../usage/execution.rst:778
# 8f2451c8bb28439e9a950f8d22a0f028
msgid "Specifically, each time a password prompt is presented to the user, the value entered is used to update both the single default password cache, and the cache value for the current value of ``env.host_string``."
msgstr ""

#: ../../usage/execution.rst:782
# ff416b42d28a4258b52a7f148cdafb3b
msgid "We highly recommend the use of SSH `key-based access <http://en.wikipedia.org/wiki/Public_key>`_ instead of relying on homogeneous password setups, as it's significantly more secure."
msgstr ""

#: ../../usage/execution.rst:790
# 1196a65ac8634acdaaa31218b1ea0ccf
msgid "Leveraging native SSH config files"
msgstr ""

#: ../../usage/execution.rst:792
# be5e55dd0bf443f2bf795d05a95a775d
msgid "Command-line SSH clients (such as the one provided by `OpenSSH <http://openssh.org>`_) make use of a specific configuration format typically known as ``ssh_config``, and will read from a file in the platform-specific location ``$HOME/.ssh/config`` (or an arbitrary path given to :option:`--ssh-config-path`/:ref:`env.ssh_config_path <ssh-config-path>`.) This file allows specification of various SSH options such as default or per-host usernames, hostname aliases, and toggling other settings (such as whether to use :ref:`agent forwarding <forward-agent>`.)"
msgstr ""

#: ../../usage/execution.rst:801
# 611749d851e24d8486c1db0f2ab41af3
msgid "Fabric's SSH implementation allows loading a subset of these options from one's actual SSH config file, should it exist. This behavior is not enabled by default (in order to be backwards compatible) but may be turned on by setting :ref:`env.use_ssh_config <use-ssh-config>` to ``True`` at the top of your fabfile."
msgstr ""

#: ../../usage/execution.rst:807
# 07b88c8e409143ab8da9dda3ed9fb578
msgid "If enabled, the following SSH config directives will be loaded and honored by Fabric:"
msgstr ""

#: ../../usage/execution.rst:809
# 3e3db04eaa1c4b2a933a4fb6b354e17a
msgid "``User`` and ``Port`` will be used to fill in the appropriate connection parameters when not otherwise specified, in the following fashion:"
msgstr ""

#: ../../usage/execution.rst:812
# 216d6322920a4c32a84188b78f120081
msgid "Globally specified ``User``/``Port`` will be used in place of the current defaults (local username and 22, respectively) if the appropriate env vars are not set."
msgstr ""

#: ../../usage/execution.rst:815
# 07e4f49147ec42829ee17c5dd9812093
msgid "However, if :ref:`env.user <user>`/:ref:`env.port <port>` *are* set, they override global ``User``/``Port`` values."
msgstr ""

#: ../../usage/execution.rst:817
# 379a0f9b3705487da402df8f6e0eeb43
msgid "User/port values in the host string itself (e.g. ``hostname:222``) will override everything, including any ``ssh_config`` values."
msgstr ""

#: ../../usage/execution.rst:819
# 459e7e4578d34abd915ed1e3ae052bb1
msgid "``HostName`` can be used to replace the given hostname, just like with regular ``ssh``. So a ``Host foo`` entry specifying ``HostName example.com`` will allow you to give Fabric the hostname ``'foo'`` and have that expanded into ``'example.com'`` at connection time."
msgstr ""

#: ../../usage/execution.rst:823
# f57d2f01a55d4cde9541cf0a139b351e
msgid "``IdentityFile`` will extend (not replace) :ref:`env.key_filename <key-filename>`."
msgstr ""

#: ../../usage/execution.rst:825
# 9a07043557f44db88641517a1e5ba070
msgid "``ForwardAgent`` will augment :ref:`env.forward_agent <forward-agent>` in an \"OR\" manner: if either is set to a positive value, agent forwarding will be enabled."
msgstr ""

#: ../../usage/execution.rst:828
# 03fc3df28c084ba18dfa06f9fdc73d65
msgid "``ProxyCommand`` will trigger use of a proxy command for host connections, just as with regular ``ssh``."
msgstr ""

#: ../../usage/execution.rst:832
# 2fb3b631964d4db8b172800d4f229458
msgid "If all you want to do is bounce SSH traffic off a gateway, you may find :ref:`env.gateway <gateway>` to be a more efficient connection method (which will also honor more Fabric-level settings) than the typical ``ssh gatewayhost nc %h %p`` method of using ``ProxyCommand`` as a gateway."
msgstr ""

#: ../../usage/execution.rst:838
# cda60fc004c14ed48ee7956f19d0cdb1
msgid "If your SSH config file contains ``ProxyCommand`` directives *and* you have set :ref:`env.gateway <gateway>` to a non-``None`` value, ``env.gateway`` will take precedence and the ``ProxyCommand`` will be ignored."
msgstr ""

#: ../../usage/execution.rst:842
# a1805022b9014880a7c794c7ac3d8cf1
msgid "If one has a pre-created SSH config file, rationale states it will be easier for you to modify ``env.gateway`` (e.g. via `~fabric.context_managers.settings`) than to work around your conf file's contents entirely."
msgstr ""

