# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, Christian Vest Hansen and Jeffrey E. Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-01-03 19:54+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../usage/fabfiles.rst:3
# 0c27e23987dd48889ee33ccf2a33be0a
msgid "Fabfile construction and use"
msgstr ""

#: ../../usage/fabfiles.rst:5
# e3922dacf4d240478403a2827214bbf6
msgid "This document contains miscellaneous sections about fabfiles, both how to best write them, and how to use them once written."
msgstr ""

#: ../../usage/fabfiles.rst:11
# cb0cc8e251d84ca5a72d835cf68f60b7
msgid "Fabfile discovery"
msgstr ""

#: ../../usage/fabfiles.rst:13
# 0934929421a543b4bca448cb5f9c2e52
msgid "Fabric is capable of loading Python modules (e.g. ``fabfile.py``) or packages (e.g. a ``fabfile/`` directory containing an ``__init__.py``). By default, it looks for something named (to Python's import machinery) ``fabfile`` - so either ``fabfile/`` or ``fabfile.py``."
msgstr ""

#: ../../usage/fabfiles.rst:18
# a393069955814772879e7f3eb1f30ef8
msgid "The fabfile discovery algorithm searches in the invoking user's current working directory or any parent directories. Thus, it is oriented around \"project\" use, where one keeps e.g. a ``fabfile.py`` at the root of a source code tree. Such a fabfile will then be discovered no matter where in the tree the user invokes ``fab``."
msgstr ""

#: ../../usage/fabfiles.rst:24
# c27041ffeb484fcaa04f5cce7062f068
msgid "The specific name to be searched for may be overridden on the command-line with the :option:`-f` option, or by adding a :ref:`fabricrc <fabricrc>` line which sets the value of ``fabfile``. For example, if you wanted to name your fabfile ``fab_tasks.py``, you could create such a file and then call ``fab -f fab_tasks.py <task name>``, or add ``fabfile = fab_tasks.py`` to ``~/.fabricrc``."
msgstr ""

#: ../../usage/fabfiles.rst:31
# 0b3096ba387445cfaa5959a0175e5898
msgid "If the given fabfile name contains path elements other than a filename (e.g. ``../fabfile.py`` or ``/dir1/dir2/custom_fabfile``) it will be treated as a file path and directly checked for existence without any sort of searching. When in this mode, tilde-expansion will be applied, so one may refer to e.g. ``~/personal_fabfile.py``."
msgstr ""

#: ../../usage/fabfiles.rst:39
# 73f8ab9ca8e641f48d3261b24adadaa1
msgid "Fabric does a normal ``import`` (actually an ``__import__``) of your fabfile in order to access its contents -- it does not do any ``eval``-ing or similar. In order for this to work, Fabric temporarily adds the found fabfile's containing folder to the Python load path (and removes it immediately afterwards.)"
msgstr ""

#: ../../usage/fabfiles.rst:45
# 9322fdb9d6d54c72846fb193b06a8183
msgid "The ability to load package fabfiles."
msgstr ""

#: ../../usage/fabfiles.rst:52
# d633af24694f451f843dec4feb162a59
msgid "Importing Fabric"
msgstr ""

#: ../../usage/fabfiles.rst:54
# 22c98f28ef1a42d481668466f4e0bc7c
msgid "Because Fabric is just Python, you *can* import its components any way you want. However, for the purposes of encapsulation and convenience (and to make life easier for Fabric's packaging script) Fabric's public API is maintained in the ``fabric.api`` module."
msgstr ""

#: ../../usage/fabfiles.rst:59
# d2952429dfa543cebba5ca799236c10e
msgid "All of Fabric's :doc:`../api/core/operations`, :doc:`../api/core/context_managers`, :doc:`../api/core/decorators` and :doc:`../api/core/utils` are included in this module as a single, flat namespace. This enables a very simple and consistent interface to Fabric within your fabfiles::"
msgstr ""

#: ../../usage/fabfiles.rst:69
# eeeab2e4b54b4e09b8c9ed970fa700fc
msgid "This is not technically best practices (for `a number of reasons`_) and if you're only using a couple of Fab API calls, it *is* probably a good idea to explicitly ``from fabric.api import env, run`` or similar. However, in most nontrivial fabfiles, you'll be using all or most of the API, and the star import::"
msgstr ""

#: ../../usage/fabfiles.rst:77
# 0326252055b94b5495bc3cc2887af42d
msgid "will be a lot easier to write and read than::"
msgstr ""

#: ../../usage/fabfiles.rst:82
# 1036f16c174c4529b1ca57c705e5797a
msgid "so in this case we feel pragmatism overrides best practices."
msgstr ""

#: ../../usage/fabfiles.rst:88
# c622abfc875c43b3afe2af48eaeef3a5
msgid "Defining tasks and importing callables"
msgstr ""

#: ../../usage/fabfiles.rst:90
# 958fe4a607dc4dfe860d1f05df06e6c7
msgid "For important information on what exactly Fabric will consider as a task when it loads your fabfile, as well as notes on how best to import other code, please see :doc:`/usage/tasks` in the :doc:`execution` documentation."
msgstr ""

