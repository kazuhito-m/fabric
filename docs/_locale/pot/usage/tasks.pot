# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014, Christian Vest Hansen and Jeffrey E. Forcier
# This file is distributed under the same license as the Fabric package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Fabric 1.8\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-01-03 19:54+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../usage/tasks.rst:3
# 9b9f366be4104d4182d6fa1a9be4ec27
msgid "Defining tasks"
msgstr ""

#: ../../usage/tasks.rst:5
# 6205d36613524318801e5c9a73f6f550
msgid "As of Fabric 1.1, there are two distinct methods you may use in order to define which objects in your fabfile show up as tasks:"
msgstr ""

#: ../../usage/tasks.rst:8
# 935427542c454f59b4cedcd0b9631ccb
msgid "The \"new\" method starting in 1.1 considers instances of `~fabric.tasks.Task` or its subclasses, and also descends into imported modules to allow building nested namespaces."
msgstr ""

#: ../../usage/tasks.rst:11
# 95eea983309b47cd9f79db97266106f1
msgid "The \"classic\" method from 1.0 and earlier considers all public callable objects (functions, classes etc) and only considers the objects in the fabfile itself with no recursing into imported module."
msgstr ""

#: ../../usage/tasks.rst:16
# 82a056729b51431aa91e98f5f31e6cd9
msgid "These two methods are **mutually exclusive**: if Fabric finds *any* new-style task objects in your fabfile or in modules it imports, it will assume you've committed to this method of task declaration and won't consider any non-`~fabric.tasks.Task` callables. If *no* new-style tasks are found, it reverts to the classic behavior."
msgstr ""

#: ../../usage/tasks.rst:22
# 2ed8c7d3bfb4443593b16edb5e02e938
msgid "The rest of this document explores these two methods in detail."
msgstr ""

#: ../../usage/tasks.rst:26
# bc32aa936d8c471fb548637fa8e44c2f
msgid "To see exactly what tasks in your fabfile may be executed via ``fab``, use :option:`fab --list <-l>`."
msgstr ""

#: ../../usage/tasks.rst:32
# 6cbc024b6d214e6cb58f08963c4f5f7e
msgid "New-style tasks"
msgstr ""

#: ../../usage/tasks.rst:34
# 0ecf8d4396554bb0b6962be11a5715f1
msgid "Fabric 1.1 introduced the `~fabric.tasks.Task` class to facilitate new features and enable some programming best practices, specifically:"
msgstr ""

#: ../../usage/tasks.rst:37
# 846fcf415ac64e2fa4bcc5187e2e32e9
msgid "**Object-oriented tasks**. Inheritance and all that comes with it can make for much more sensible code reuse than passing around simple function objects.  The classic style of task declaration didn't entirely rule this out, but it also didn't make it terribly easy."
msgstr ""

#: ../../usage/tasks.rst:41
# 1f7090b9e6ed48869623139607ef97bd
msgid "**Namespaces**. Having an explicit method of declaring tasks makes it easier to set up recursive namespaces without e.g. polluting your task list with the contents of Python's ``os`` module (which would show up as valid \"tasks\" under the classic methodology.)"
msgstr ""

#: ../../usage/tasks.rst:46
# 2ccfdd42e14846369915d4234bee189a
msgid "With the introduction of `~fabric.tasks.Task`, there are two ways to set up new tasks:"
msgstr ""

#: ../../usage/tasks.rst:49
# 65ef7d4aaa4b4cca88e4885fc01a5b24
msgid "Decorate a regular module level function with `@task <fabric.decorators.task>`, which transparently wraps the function in a `~fabric.tasks.Task` subclass.  The function name will be used as the task name when invoking."
msgstr ""

#: ../../usage/tasks.rst:53
# 58f2f558cd2543a299a5a5f2b3156524
msgid "Subclass `~fabric.tasks.Task` (`~fabric.tasks.Task` itself is intended to be abstract), define a ``run`` method, and instantiate your subclass at module level. Instances' ``name`` attributes are used as the task name; if omitted the instance's variable name will be used instead."
msgstr ""

#: ../../usage/tasks.rst:58
# a12cb9083d3c459e980d5e20f99de21a
msgid "Use of new-style tasks also allows you to set up :ref:`namespaces <namespaces>`."
msgstr ""

#: ../../usage/tasks.rst:65
# 2464bd814298404194eb4f30b5fb116c
msgid "The ``@task`` decorator"
msgstr ""

#: ../../usage/tasks.rst:67
# 2bedd1913858477aa36160146bc87fd0
msgid "The quickest way to make use of new-style task features is to wrap basic task functions with `@task <fabric.decorators.task>`::"
msgstr ""

#: ../../usage/tasks.rst:76
# 3000e7fca69c41b69618804a3cfb18e1
msgid "When this decorator is used, it signals to Fabric that *only* functions wrapped in the decorator are to be loaded up as valid tasks. (When not present, :ref:`classic-style task <classic-tasks>` behavior kicks in.)"
msgstr ""

#: ../../usage/tasks.rst:81
# e5831318dca6461280db0f256df79d42
msgid "Arguments"
msgstr ""

#: ../../usage/tasks.rst:83
# aa9132a426944c0c828eb3910b9c0058
msgid "`@task <fabric.decorators.task>` may also be called with arguments to customize its behavior. Any arguments not documented below are passed into the constructor of the ``task_class`` being used, with the function itself as the first argument (see :ref:`task-decorator-and-classes` for details.)"
msgstr ""

#: ../../usage/tasks.rst:88
# 10a16eb69b234fce8113265a79e7bc46
msgid "``task_class``: The `~fabric.tasks.Task` subclass used to wrap the decorated function. Defaults to `~fabric.tasks.WrappedCallableTask`."
msgstr ""

#: ../../usage/tasks.rst:90
# cfec04b25ea54c56a0f32323b2047194
msgid "``aliases``: An iterable of string names which will be used as aliases for the wrapped function. See :ref:`task-aliases` for details."
msgstr ""

#: ../../usage/tasks.rst:92
# c6fadbb02a1b409fb51c8bb1572380dd
msgid "``alias``: Like ``aliases`` but taking a single string argument instead of an iterable. If both ``alias`` and ``aliases`` are specified, ``aliases`` will take precedence."
msgstr ""

#: ../../usage/tasks.rst:95
# 57bbd99fa6cf4899af2e92b40e9bc569
msgid "``default``: A boolean value determining whether the decorated task also stands in for its containing module as a task name. See :ref:`default-tasks`."
msgstr ""

#: ../../usage/tasks.rst:97
# 017a898b73774754b5c0d75c06b3a591
msgid "``name``: A string setting the name this task appears as to the command-line interface. Useful for task names that would otherwise shadow Python builtins (which is technically legal but frowned upon and bug-prone.)"
msgstr ""

#: ../../usage/tasks.rst:104
# f61dc5217dea4bef82d289ef7a72d5dd
msgid "Aliases"
msgstr ""

#: ../../usage/tasks.rst:106
# e714dfa247794654bcf32e175fc94575
msgid "Here's a quick example of using the ``alias`` keyword argument to facilitate use of both a longer human-readable task name, and a shorter name which is quicker to type::"
msgstr ""

#: ../../usage/tasks.rst:116
# 55e00328f235421ea43ec22469dc819b
msgid "Calling :option:`--list <-l>` on this fabfile would show both the original ``deploy_with_migrations`` and its alias ``dwm``::"
msgstr ""

#: ../../usage/tasks.rst:125
# b3f9338662e04e70bee60ceaa4dcf082
msgid "When more than one alias for the same function is needed, simply swap in the ``aliases`` kwarg, which takes an iterable of strings instead of a single string."
msgstr ""

#: ../../usage/tasks.rst:132
# beb83ade7730416fb17345cbdfe11336
msgid "Default tasks"
msgstr ""

#: ../../usage/tasks.rst:134
# 88ba6900847942ab811d29c1cbf0fcd3
msgid "In a similar manner to :ref:`aliases <task-aliases>`, it's sometimes useful to designate a given task within a module as the \"default\" task, which may be called by referencing *just* the module name. This can save typing and/or allow for neater organization when there's a single \"main\" task and a number of related tasks or subroutines."
msgstr ""

#: ../../usage/tasks.rst:140
# ecc65e44db2148afb267b29c361be2c7
msgid "For example, a ``deploy`` submodule might contain tasks for provisioning new servers, pushing code, migrating databases, and so forth -- but it'd be very convenient to highlight a task as the default \"just deploy\" action. Such a ``deploy.py`` module might look like this::"
msgstr ""

#: ../../usage/tasks.rst:166
# 169751583d7d4ea886dd31ff2e578bf7
msgid "With the following task list (assuming a simple top level ``fabfile.py`` that just imports ``deploy``)::"
msgstr ""

#: ../../usage/tasks.rst:176
# bdbbccc7da4743a4bfa5416351ed872c
msgid "Calling ``deploy.full_deploy`` on every deploy could get kind of old, or somebody new to the team might not be sure if that's really the right task to run."
msgstr ""

#: ../../usage/tasks.rst:178
# c4c908bf95e5427cba9c5d10d1db9dd4
msgid "Using the ``default`` kwarg to `@task <fabric.decorators.task>`, we can tag e.g. ``full_deploy`` as the default task::"
msgstr ""

#: ../../usage/tasks.rst:185
# b5a6ff2dc98b45ce953987ab80143b85
msgid "Doing so updates the task list like so::"
msgstr ""

#: ../../usage/tasks.rst:196
# a8ebf059b9964634822cee0d2dab1024
msgid "Note that ``full_deploy`` still exists as its own explicit task -- but now ``deploy`` shows up as a sort of top level alias for ``full_deploy``."
msgstr ""

#: ../../usage/tasks.rst:199
# 847a002c76394480b29ed36caa5a30bd
msgid "If multiple tasks within a module have ``default=True`` set, the last one to be loaded (typically the one lowest down in the file) will take precedence."
msgstr ""

#: ../../usage/tasks.rst:203
# 7c65ce1781b7448b94cd6dd5ff0b8a73
msgid "Top-level default tasks"
msgstr ""

#: ../../usage/tasks.rst:205
# 5756a3e395ce4e5584c8de2da30c54c2
msgid "Using ``@task(default=True)`` in the top level fabfile will cause the denoted task to execute when a user invokes ``fab`` without any task names (similar to e.g. ``make``.) When using this shortcut, it is not possible to specify arguments to the task itself -- use a regular invocation of the task if this is necessary."
msgstr ""

#: ../../usage/tasks.rst:214
# 77637ecf90944fa5a4e46ffc47835315
msgid "``Task`` subclasses"
msgstr ""

#: ../../usage/tasks.rst:216
# fe8a396b37e8462d8a5ce84fdf1e3d50
msgid "If you're used to :ref:`classic-style tasks <classic-tasks>`, an easy way to think about `~fabric.tasks.Task` subclasses is that their ``run`` method is directly equivalent to a classic task; its arguments are the task arguments (other than ``self``) and its body is what gets executed."
msgstr ""

#: ../../usage/tasks.rst:221
# 72fff58aefc04a0db37267121c37d0d6
msgid "For example, this new-style task::"
msgstr ""

#: ../../usage/tasks.rst:231
# c84fac4505004702bd692b105668f5f8
msgid "is exactly equivalent to this function-based task::"
msgstr ""

#: ../../usage/tasks.rst:238
# 70bc5c1c360b4185886476767771fa81
msgid "Note how we had to instantiate an instance of our class; that's simply normal Python object-oriented programming at work. While it's a small bit of boilerplate right now -- for example, Fabric doesn't care about the name you give the instantiation, only the instance's ``name`` attribute -- it's well worth the benefit of having the power of classes available."
msgstr ""

#: ../../usage/tasks.rst:244
# 60e3050958fc4657afe1bfe2b5fdd69f
msgid "We plan to extend the API in the future to make this experience a bit smoother."
msgstr ""

#: ../../usage/tasks.rst:249
# e0878a1701b54a90addbf1c0dcd67e7b
msgid "Using custom subclasses with ``@task``"
msgstr ""

#: ../../usage/tasks.rst:251
# ec3804adcdde40ccaa6f43fcd8fbd5a9
msgid "It's possible to marry custom `~fabric.tasks.Task` subclasses with `@task <fabric.decorators.task>`. This may be useful in cases where your core execution logic doesn't do anything class/object-specific, but you want to take advantage of class metaprogramming or similar techniques."
msgstr ""

#: ../../usage/tasks.rst:256
# 4d0e78221d4a495180ea464fc0656bb2
msgid "Specifically, any `~fabric.tasks.Task` subclass which is designed to take in a callable as its first constructor argument (as the built-in `~fabric.tasks.WrappedCallableTask` does) may be specified as the ``task_class`` argument to `@task <fabric.decorators.task>`."
msgstr ""

#: ../../usage/tasks.rst:261
# 84699b481cbf48bea54c6e1f7117b798
msgid "Fabric will automatically instantiate a copy of the given class, passing in the wrapped function as the first argument. All other args/kwargs given to the decorator (besides the \"special\" arguments documented in :ref:`task-decorator-arguments`) are added afterwards."
msgstr ""

#: ../../usage/tasks.rst:266
# 933d404c3eda44d99ac791647620a560
msgid "Here's a brief and somewhat contrived example to make this obvious::"
msgstr ""

#: ../../usage/tasks.rst:284
# 2c08963899844d76b605be63d9bfab7d
msgid "When this fabfile is loaded, a copy of ``CustomTask`` is instantiated, effectively calling::"
msgstr ""

#: ../../usage/tasks.rst:288
# 03b0b2eaecbf42d29f243b58a586411f
msgid "Note how the ``alias`` kwarg is stripped out by the decorator itself and never reaches the class instantiation; this is identical in function to how :ref:`command-line task arguments <task-arguments>` work."
msgstr ""

#: ../../usage/tasks.rst:295
# 2206e8c50786406ab49a661cbc9ce2a9
msgid "Namespaces"
msgstr ""

#: ../../usage/tasks.rst:297
# 89bb7b10c3e94aa4915a50308f3a9995
msgid "With :ref:`classic tasks <classic-tasks>`, fabfiles were limited to a single, flat set of task names with no real way to organize them.  In Fabric 1.1 and newer, if you declare tasks the new way (via `@task <fabric.decorators.task>` or your own `~fabric.tasks.Task` subclass instances) you may take advantage of **namespacing**:"
msgstr ""

#: ../../usage/tasks.rst:303
# d06fb359fca8443fbf571f65acb7bb3c
msgid "Any module objects imported into your fabfile will be recursed into, looking for additional task objects."
msgstr ""

#: ../../usage/tasks.rst:305
# 91bac7f22ecf4c68bac190e63f9bd7be
msgid "Within submodules, you may control which objects are \"exported\" by using the standard Python ``__all__`` module-level variable name (thought they should still be valid new-style task objects.)"
msgstr ""

#: ../../usage/tasks.rst:308
# 52389df6d5514e1a97cdbe3d36928a6e
msgid "These tasks will be given new dotted-notation names based on the modules they came from, similar to Python's own import syntax."
msgstr ""

#: ../../usage/tasks.rst:311
# 9a21b6c858ec474c81d085cae7842f93
msgid "Let's build up a fabfile package from simple to complex and see how this works."
msgstr ""

#: ../../usage/tasks.rst:314
# b6d85c4986a94832ad17258f9e261e35
msgid "Basic"
msgstr ""

#: ../../usage/tasks.rst:316
# b14b7ee2e612456f8c11b0316d72bd50
msgid "We start with a single `__init__.py` containing a few tasks (the Fabric API import omitted for brevity)::"
msgstr ""

#: ../../usage/tasks.rst:327
# d8ac9eed2bb94a279d5f3ea95d1cf03a
msgid "The output of ``fab --list`` would look something like this::"
msgstr ""

#: ../../usage/tasks.rst:332
# a800aebc5dc948b896c52e04f6c53e06
msgid "There's just one namespace here: the \"root\" or global namespace. Looks simple now, but in a real-world fabfile with dozens of tasks, it can get difficult to manage."
msgstr ""

#: ../../usage/tasks.rst:337
# 1493cf232594419fa202adbcf6ccab9b
msgid "Importing a submodule"
msgstr ""

#: ../../usage/tasks.rst:339
# 9b44c5a0a7284a43b04a3427d48f2c9b
msgid "As mentioned above, Fabric will examine any imported module objects for tasks, regardless of where that module exists on your Python import path.  For now we just want to include our own, \"nearby\" tasks, so we'll make a new submodule in our package for dealing with, say, load balancers -- ``lb.py``::"
msgstr ""

#: ../../usage/tasks.rst:348
# 537b22bc17484de0b847781e84612ede
msgid "And we'll add this to the top of ``__init__.py``::"
msgstr ""

#: ../../usage/tasks.rst:352
# 11c58d775c724ebc9889a2f13423d664
msgid "Now ``fab --list`` shows us::"
msgstr ""

#: ../../usage/tasks.rst:358
# 177f1fb7bd9c491c8fed84b51ff7175d
msgid "Again, with only one task in its own submodule, it looks kind of silly, but the benefits should be pretty obvious."
msgstr ""

#: ../../usage/tasks.rst:362
# b61aa546cf0c4b01ab8467a9546b1824
msgid "Going deeper"
msgstr ""

#: ../../usage/tasks.rst:364
# debc050973c24317b05757ae2f5aa088
msgid "Namespacing isn't limited to just one level. Let's say we had a larger setup and wanted a namespace for database related tasks, with additional differentiation inside that. We make a sub-package named ``db/`` and inside it, a ``migrations.py`` module::"
msgstr ""

#: ../../usage/tasks.rst:377
# ae2652dd5b6046359a55dfabfc5ab51b
msgid "We need to make sure that this module is visible to anybody importing ``db``, so we add it to the sub-package's ``__init__.py``::"
msgstr ""

#: ../../usage/tasks.rst:382
# d5dca311a7d247949d7a95e11d9be10a
msgid "As a final step, we import the sub-package into our root-level ``__init__.py``, so now its first few lines look like this::"
msgstr ""

#: ../../usage/tasks.rst:388
# 6ad4d8da519f45aebad5a076cc5a6ac9
msgid "After all that, our file tree looks like this::"
msgstr ""

#: ../../usage/tasks.rst:397
# 07c381087451425181528eb4619a7518
msgid "and ``fab --list`` shows::"
msgstr ""

#: ../../usage/tasks.rst:405
# 01103ab423024df3bf5ccf0f58e5bbd1
msgid "We could also have specified (or imported) tasks directly into ``db/__init__.py``, and they would show up as ``db.<whatever>`` as you might expect."
msgstr ""

#: ../../usage/tasks.rst:410
# 447a2e92dbc343a3b65f547b46f37643
msgid "Limiting with ``__all__``"
msgstr ""

#: ../../usage/tasks.rst:412
# 34e2089215f04cf8a03bbf58e94fc042
msgid "You may limit what Fabric \"sees\" when it examines imported modules, by using the Python convention of a module level ``__all__`` variable (a list of variable names.) If we didn't want the ``db.migrations.run`` task to show up by default for some reason, we could add this to the top of ``db/migrations.py``::"
msgstr ""

#: ../../usage/tasks.rst:419
# 8a33dd90646c4d87bad5ca876d314747
msgid "Note the lack of ``'run'`` there. You could, if needed, import ``run`` directly into some other part of the hierarchy, but otherwise it'll remain hidden."
msgstr ""

#: ../../usage/tasks.rst:423
# 4deeb01d94a54ede8e2da9dda94be96d
msgid "Switching it up"
msgstr ""

#: ../../usage/tasks.rst:425
# 6f0332d74b6c4cd591fd02215f6ead89
msgid "We've been keeping our fabfile package neatly organized and importing it in a straightforward manner, but the filesystem layout doesn't actually matter here. All Fabric's loader cares about is the names the modules are given when they're imported."
msgstr ""

#: ../../usage/tasks.rst:430
# 600f021244cb426aa3a9f320c72451d9
msgid "For example, if we changed the top of our root ``__init__.py`` to look like this::"
msgstr ""

#: ../../usage/tasks.rst:435
# 5142b2e36e4e48e28e41eeb5be1d9580
msgid "Our task list would change thusly::"
msgstr ""

#: ../../usage/tasks.rst:443
# 318b86e9d7174c6789bbd8179bb3a90a
msgid "This applies to any other import -- you could import third party modules into your own task hierarchy, or grab a deeply nested module and make it appear near the top level."
msgstr ""

#: ../../usage/tasks.rst:448
# bc6952bcff86408b830a0d252ae6d8d5
msgid "Nested list output"
msgstr ""

#: ../../usage/tasks.rst:450
# 53b8f98b2d4e41c39c510486c71b0df6
msgid "As a final note, we've been using the default Fabric :option:`--list <-l>` output during this section -- it makes it more obvious what the actual task names are. However, you can get a more nested or tree-like view by passing ``nested`` to the :option:`--list-format <-F>` option::"
msgstr ""

#: ../../usage/tasks.rst:467
# 18ba02b9509843de9f548dbd4d38e16e
msgid "While it slightly obfuscates the \"real\" task names, this view provides a handy way of noting the organization of tasks in large namespaces."
msgstr ""

#: ../../usage/tasks.rst:474
# 15a8747cdc794c23acc80e70add799a3
msgid "Classic tasks"
msgstr ""

#: ../../usage/tasks.rst:476
# 1e593f6b19b14c62bcb85a082b07f561
msgid "When no new-style `~fabric.tasks.Task`-based tasks are found, Fabric will consider any callable object found in your fabfile, **except** the following:"
msgstr ""

#: ../../usage/tasks.rst:479
# fb7e610c7c814139837a785b092c9ea1
msgid "Callables whose name starts with an underscore (``_``). In other words, Python's usual \"private\" convention holds true here."
msgstr ""

#: ../../usage/tasks.rst:481
# 94a3a2984fdd42b58a4d7474013e5507
msgid "Callables defined within Fabric itself. Fabric's own functions such as `~fabric.operations.run` and `~fabric.operations.sudo`  will not show up in your task list."
msgstr ""

#: ../../usage/tasks.rst:487
# d2e4fb3c0d5f4eeda4da3115564236e8
msgid "Imports"
msgstr ""

#: ../../usage/tasks.rst:489
# ffc9bd05954d44dd8f42210ded0f25e4
msgid "Python's ``import`` statement effectively includes the imported objects in your module's namespace. Since Fabric's fabfiles are just Python modules, this means that imports are also considered as possible classic-style tasks, alongside anything defined in the fabfile itself."
msgstr ""

#: ../../usage/tasks.rst:495
# becad7808e9a48549978b21b80fdd968
msgid "This only applies to imported *callable objects* -- not modules. Imported modules only come into play if they contain :ref:`new-style tasks <new-style-tasks>`, at which point this section no longer applies."
msgstr ""

#: ../../usage/tasks.rst:500
# 3f5f4ed584094eceaf1dbb21ca66a90d
msgid "Because of this, we strongly recommend that you use the ``import module`` form of importing, followed by ``module.callable()``, which will result in a cleaner fabfile API than doing ``from module import callable``."
msgstr ""

#: ../../usage/tasks.rst:504
# 1e24a5ffc2754e5eb5c2cec4a6761990
msgid "For example, here's a sample fabfile which uses ``urllib.urlopen`` to get some data out of a webservice::"
msgstr ""

#: ../../usage/tasks.rst:515
# 9138bbce4e6645dba16727dbb8985958
msgid "This looks simple enough, and will run without error. However, look what happens if we run :option:`fab --list <-l>` on this fabfile::"
msgstr ""

#: ../../usage/tasks.rst:524
# 36d0b8fab1de4887b4c3617ccf3ba887
msgid "Our fabfile of only one task is showing two \"tasks\", which is bad enough, and an unsuspecting user might accidentally try to call ``fab urlopen``, which probably won't work very well. Imagine any real-world fabfile, which is likely to be much more complex, and hopefully you can see how this could get messy fast."
msgstr ""

#: ../../usage/tasks.rst:530
# 262224ffd9a1435399c126d3e9fd32df
msgid "For reference, here's the recommended way to do it::"
msgstr ""

#: ../../usage/tasks.rst:540
# 27df77b5fbda4e6ebc6f4a3c160cba91
msgid "It's a simple change, but it'll make anyone using your fabfile a bit happier."
msgstr ""

